<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【转载】Android 操作系统架构开篇</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p><strong>版权声明：</strong> 本站所有博文内容均为原创，转载请务必注明作者与原文链接，且不得篡改原文内容。</p>
</blockquote>
<p>为便于日常查阅本博客，可通过 <strong><a href="http://gityuan.com/archive/" target="_blank" rel="noopener">Gityuan博客导航</a></strong> 方便检索文章</p>
<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><p>众所周知，Android是谷歌开发的一款基于Linux的开源操作系统，从诞生至今已有10余年，这一路走来Android遇到哪些问题？大版本升级朝着什么方向演进？Android的未来如何？我的公号<a href="https://mp.weixin.qq.com/s/W38aauoCEEUbL8KvUkb_Rw" target="_blank" rel="noopener">《Android 技术架构演进与未来》</a> 讲解了Android一路走来，在用户体验、性能、功耗、安全、隐私等方面取得的很大进步，以及未来可能的方向。</p>
<p>本文作为Android系统架构的开篇，起到提纲挈领的作用，从系统整体架构角度概要讲解Android系统的核心技术点，带领大家初探Android系统全貌以及内部运作机制。虽然Android系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p>
<p>为了能让大家整体上大致了解Android系统涉及的知识层面，先来看一张Google官方提供的经典分层架构图，从下往上依次分为Linux内核、HAL、系统Native库和Android运行时环境、Java框架层以及应用层这5层架构，其中每一层都包含大量的子模块或子系统。</p>
<p><img src="http://gityuan.com/images/android-arch/android-stack.png" alt="android-stack"></p>
<p>上图采用静态分层方式的架构划分，众所周知，程序代码是死的，系统运转是活的，各模块代码运行在不同的进程(线程)中，相互之间进行着各种错终复杂的信息传递与交互流，从这个角度来说此图并没能体现Android整个系统的内部架构、运行机理，以及各个模块之间是如何衔接与配合工作的。</p>
<p><strong>为了更深入地掌握Android整个架构思想以及各个模块在Android系统所处的地位与价值，计划以Android系统启动过程为主线，以进程的视角来诠释Android M系统全貌</strong>，全方位的深度剖析各个模块功能，争取各个击破。这样才能犹如庖丁解牛，解决、分析问题则能游刃有余。</p>
<h3 id="二、Android架构"><a href="#二、Android架构" class="headerlink" title="二、Android架构"></a>二、Android架构</h3><p>Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌，阐述Android内部的环环相扣的内在联系。</p>
<p><strong>系统启动架构图</strong></p>
<p>点击查看<a href="http://gityuan.com/images/android-arch/android-boot.jpg" target="_blank" rel="noopener">大图</a></p>
<p><img src="http://gityuan.com/images/android-arch/android-boot.jpg" alt="process_status"></p>
<p><strong>图解：</strong> Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; <code>Kernel</code> -&gt; <code>Native</code> -&gt; <code>Framework</code> -&gt; <code>App</code>，接来下简要说说每个过程：</p>
<p>关于Loader层：</p>
<ul>
<li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在<code>ROM</code>里的预设代码开始执行，然后加载引导程序到<code>RAM</code>；</li>
<li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。</li>
</ul>
<h4 id="2-1-Linux内核层"><a href="#2-1-Linux内核层" class="headerlink" title="2.1 Linux内核层"></a>2.1 Linux内核层</h4><p>Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</p>
<ul>
<li>启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li>
<li>启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<code>kthreadd进程是所有内核进程的鼻祖</code>。</li>
</ul>
<h4 id="2-2-硬件抽象层-HAL"><a href="#2-2-硬件抽象层-HAL" class="headerlink" title="2.2 硬件抽象层 (HAL)"></a>2.2 硬件抽象层 (HAL)</h4><p>硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p>
<h4 id="2-3-Android-Runtime-amp-系统库"><a href="#2-3-Android-Runtime-amp-系统库" class="headerlink" title="2.3 Android Runtime &amp; 系统库"></a>2.3 Android Runtime &amp; 系统库</h4><p>每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。</p>
<p>这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，<code>init进程是所有用户进程的鼻祖</code>。</p>
<ul>
<li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li>
<li>init进程还启动<code>servicemanager</code>(binder服务管家)、<code>bootanim</code>(开机动画)等重要服务</li>
<li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code>Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li>
</ul>
<h4 id="2-4-Framework层"><a href="#2-4-Framework层" class="headerlink" title="2.4 Framework层"></a>2.4 Framework层</h4><ul>
<li>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：<ul>
<li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li>
<li>加载虚拟机</li>
<li>提前加载类preloadClasses</li>
<li>提前加载资源preloadResouces</li>
</ul>
</li>
<li>System Server进程，是由Zygote进程fork而来，<code>System Server是Zygote孵化的第一个进程</code>，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。</li>
<li>Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</li>
</ul>
<h4 id="2-5-App层"><a href="#2-5-App层" class="headerlink" title="2.5 App层"></a>2.5 App层</h4><ul>
<li>Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</li>
<li>Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。</li>
<li>所有的App进程都是由Zygote进程fork生成的。</li>
</ul>
<h4 id="2-6-Syscall-amp-amp-JNI"><a href="#2-6-Syscall-amp-amp-JNI" class="headerlink" title="2.6 Syscall &amp;&amp; JNI"></a>2.6 Syscall &amp;&amp; JNI</h4><ul>
<li>Native与Kernel之间有一层系统调用(SysCall)层，见<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">Linux系统调用(Syscall)原理</a>;</li>
<li>Java层与Native(C/C++)层之间的纽带JNI，见<a href="http://gityuan.com/2016/05/28/android-jni/" target="_blank" rel="noopener">Android JNI原理分析</a>。</li>
</ul>
<h3 id="三、通信方式"><a href="#三、通信方式" class="headerlink" title="三、通信方式"></a>三、通信方式</h3><p>无论是Android系统，还是各种Linux衍生系统，各个组件、模块往往运行在各种不同的进程和线程内，这里就必然涉及进程/线程之间的通信。对于IPC(Inter-Process Communication, 进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media server以及上层App之间更多的是采用Binder IPC方式来完成跨进程间的通信。对于Android上层架构中，很多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。</p>
<p>想深入理解Android内核层架构，必须先深入理解Linux现有的IPC机制；对于Android上层架构，则最常用的通信方式是Binder、Socket、Handler，当然也有少量其他的IPC方式，比如杀进程Process.killProcess()采用的是signal方式。下面说说Binder、Socket、Handler：</p>
<h4 id="3-1-Binder"><a href="#3-1-Binder" class="headerlink" title="3.1 Binder"></a>3.1 Binder</h4><p>Binder作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，想了解<a href="https://www.zhihu.com/question/39440766/answer/89210950" target="_blank" rel="noopener">为什么Android要采用Binder作为IPC机制？</a> 可查看我在知乎上的回答。深入了解Binder机制，最好的方法便是阅读源码，借用Linux鼻祖Linus Torvalds曾说过的一句话：Read The Fucking Source Code。下面简要说说Binder IPC原理。</p>
<p><strong>Binder IPC原理</strong></p>
<p>Binder通信采用c/s架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。</p>
<p><img src="http://gityuan.com/images/android-arch/IPC-Binder.jpg" alt="ServiceManager"></p>
<ul>
<li>想进一步了解Binder，可查看<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a>，Binder系列花费了13篇文章的篇幅，从源码角度出发来讲述Driver、Native、Framework、App四个层面的整个完整流程。根据有些读者反馈这个系列还是不好理解，这个binder涉及的层次跨度比较大，知识量比较广，建议大家先知道binder是用于进程间通信，有个大致概念就可以先去学习系统基本知识，等后面有一定功力再进一步深入研究Binder机制。</li>
</ul>
<p><strong>Binder原理篇</strong></p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left"><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder系列—开篇</a></td>
<td align="left">Binder概述</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">Binder系列3—启动Service Manager</a></td>
<td align="left">ServiceManager守护进程 注册和查询服务</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2015/11/08/binder-get-sm/" target="_blank" rel="noopener">Binder系列4—获取Service Manager</a></td>
<td align="left">获取代理对象BpServiceManager</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">Binder系列5—注册服务(addService)</a></td>
<td align="left">注册Media服务</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/11/15/binder-get-service/" target="_blank" rel="noopener">Binder系列6—获取服务(getService)</a></td>
<td align="left">获取Media代理，以及DeathRecipient</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/21/binder-framework/" target="_blank" rel="noopener">Binder系列7—framework层分析</a></td>
<td align="left">framework层服务注册和查询，Binder注册</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Binder的startThreadPool过程</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">startService为主线</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/11/28/binder-summary/" target="_blank" rel="noopener">Binder系列10—总结</a></td>
<td align="left">Binder的简单总结</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/03/05/binder-clearCallingIdentity/" target="_blank" rel="noopener">Binder IPC的权限控制</a></td>
<td align="left">clearCallingIdentity/restoreCallingIdentity</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2016/10/03/binder_linktodeath/" target="_blank" rel="noopener">Binder死亡通知机制之linkToDeath</a></td>
<td align="left">Binder死亡通知机制</td>
</tr>
</tbody></table>
<p><strong>Binder驱动篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/01/binder-driver/" target="_blank" rel="noopener">Binder系列1—Binder Driver初探</a></th>
<th>驱动open/mmap/ioctl，以及binder结构体</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/02/binder-driver-2/" target="_blank" rel="noopener">Binder系列2—Binder Driver再探</a></td>
<td>Binder通信协议，内存机制</td>
</tr>
</tbody></table>
<p><strong>Binder使用篇:</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><a href="http://gityuan.com/2015/11/22/binder-use/" target="_blank" rel="noopener">Binder系列8—如何使用Binder</a></th>
<th>Native层、Framwrok层自定义Binder服务</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><a href="http://gityuan.com/2015/11/23/binder-aidl/" target="_blank" rel="noopener">Binder系列9—如何使用AIDL</a></td>
<td>App层自定义Binder服务</td>
</tr>
</tbody></table>
<h4 id="3-2-Socket"><a href="#3-2-Socket" class="headerlink" title="3.2 Socket"></a>3.2 Socket</h4><p>Socket通信方式也是C/S架构，比Binder简单很多。在Android系统中采用Socket通信方式的主要有：</p>
<ul>
<li>zygote：用于孵化进程，system_server创建进程是通过socket向zygote进程发起请求；</li>
<li>installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成；</li>
<li>lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成；</li>
<li>adbd：这个也不用说，用于服务adb；</li>
<li>logcatd:这个不用说，用于服务logcat；</li>
<li>vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。</li>
</ul>
<p>等等还有很多，这里不一一列举，Socket方式更多的用于Android framework层与native层之间的通信。Socket通信方式相对于binder比较简单，这里省略。</p>
<h4 id="3-3-Handler"><a href="#3-3-Handler" class="headerlink" title="3.3 Handler"></a>3.3 Handler</h4><p><strong>Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信</strong>，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制。</p>
<p>有人可能会疑惑，为何Binder/Socket用于进程间通信，能否用于线程间通信呢？答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那handler消息机制能否用于进程间通信？答案是不能，Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。很多时候，Handler是工作线程向UI主线程发送消息，即App应用中只有主线程能更新UI，其他工作线程往往是完成相应工作后，通过Handler告知主线程需要做出相应地UI更新操作，Handler分发相应的消息给UI主线程去完成，如下图：</p>
<p><img src="http://gityuan.com/images/android-arch/handler_thread_commun.jpg" alt="handler_communication"></p>
<p>由于工作线程与主线程共享地址空间，即Handler实例对象mHandler位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过mHandler向其成员变量MessageQueue中添加新Message，主线程一直处于loop()方法内，当收到新的Message时按照一定规则分发给相应的handleMessage()方法来处理。所以说，Handler消息机制用于同进程的线程间通信，其核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用handler来实现进程间通信。</p>
<p>上图只是Handler消息机制的一种处理流程，是不是只能工作线程向UI主线程发消息呢，其实不然，可以是UI线程向工作线程发送消息，也可以是多个工作线程之间通过handler发送消息。更多关于Handler消息机制文章：</p>
<ul>
<li><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制-Handler(framework篇)</a></li>
<li><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制-Handler(native篇)</a></li>
<li><a href="http://gityuan.com/2016/01/01/handler-message-usage/" target="_blank" rel="noopener">Android消息机制3-Handler(实战)</a></li>
</ul>
<p>要理解framework层源码，掌握这3种基本的进程/线程间通信方式是非常有必要，当然Linux还有不少其他的IPC机制，比如共享内存、信号、信号量，在源码中也有体现，如果想全面彻底地掌握Android系统，还是需要对每一种IPC机制都有所了解。</p>
<h3 id="四、核心提纲"><a href="#四、核心提纲" class="headerlink" title="四、核心提纲"></a>四、核心提纲</h3><p>博主对于Android从系统底层一路到上层都有自己的理解和沉淀，通过前面对系统启动的介绍，相信大家对Android系统有了一个整体观。接下来需抓核心、理思路，争取各个击破。后续将持续更新和完善整个大纲，不限于进程、内存、IO、系统服务架构以及分析实战等文章。</p>
<p>当然本站有一些文章没来得及进一步加工，有时间根据大家的反馈，不断修正和完善所有文章，争取给文章，再进一步精简非核心代码，增加可视化图表以及文字的结论性分析。基于<strong>Android 6.0的源码</strong>，专注于分享Android系统原理、架构分析的原创文章。</p>
<p><strong>建议阅读群体</strong>： 适合于正从事或者有兴趣研究Android系统的工程师或者技术爱好者，也适合Android App高级工程师；对于尚未入门或者刚入门的App工程师阅读可能会有点困难，建议先阅读更基础的资料，再来阅读本站博客。</p>
<p>看到Android整个系统架构是如此庞大的, 该问如何学习Android系统, 以下是我自己的Android的学习和研究论，仅供参考<a href="http://gityuan.com/2016/04/24/how-to-study-android/" target="_blank" rel="noopener">如何自学Android</a>。</p>
<p>从整理上来列举一下Android系统的核心知识点概览：</p>
<p><img src="http://gityuan.com/images/android-arch/android_os.png" alt="Android_os"></p>
<h4 id="4-1-系统启动系列"><a href="#4-1-系统启动系列" class="headerlink" title="4.1 系统启动系列"></a>4.1 系统启动系列</h4><p><img src="http://gityuan.com/images/android-arch/android-booting.jpg" alt="android-booting"></p>
<p><a href="http://gityuan.com/2016/02/01/android-booting/" target="_blank" rel="noopener">Android系统启动-概述</a>: Android系统中极其重要进程：init, zygote, system_server, servicemanager 进程:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">进程启动</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">init进程</a></td>
<td align="left">Linux系统中用户空间的第一个进程, Init.main</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">zygote进程</a></td>
<td align="left">所有Ａpp进程的父进程, ZygoteInit.main</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/02/14/android-system-server/" target="_blank" rel="noopener">system_server进程(上篇)</a></td>
<td align="left">系统各大服务的载体, forkSystemServer过程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">system_server进程(下篇)</a></td>
<td align="left">系统各大服务的载体, SystemServer.main</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2015/11/07/binder-start-sm/" target="_blank" rel="noopener">servicemanager进程</a></td>
<td align="left">binder服务的大管家, 守护进程循环运行在binder_loop</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">app进程</a></td>
<td align="left">通过Process.start启动App进程, ActivityThread.main</td>
</tr>
</tbody></table>
<p>再来看看守护进程(也就是进程名一般以d为后缀，比如logd，此处d是指daemon的简称), 下面介绍部分守护进程：</p>
<ul>
<li><a href="http://gityuan.com/2016/06/15/android-debuggerd/" target="_blank" rel="noopener">debuggerd</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">installd</a></li>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">lmkd</a></li>
<li><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">logd</a></li>
</ul>
<h4 id="4-2-系统稳定性系列"><a href="#4-2-系统稳定性系列" class="headerlink" title="4.2 系统稳定性系列"></a>4.2 系统稳定性系列</h4><p><a href="http://gityuan.com/2016/06/19/stability_summary/" target="_blank" rel="noopener">Android系统稳定性</a>主要是异常崩溃(crash)和执行超时(timeout),:</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="noopener">理解Android ANR的触发原理</a></td>
<td align="left">触发ANR的场景以及机理</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></td>
<td align="left">input触发ANR的原理</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="noopener">理解Android ANR的信息收集过程</a></td>
<td align="left">AMS.appNotResponding过程分析,收集traces</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></td>
<td align="left">kill -3 信息收集过程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/11/27/native-traces/" target="_blank" rel="noopener">Native进程之Trace原理</a></td>
<td align="left">debuggerd -b 信息收集过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/21/watchdog/" target="_blank" rel="noopener">WatchDog工作原理</a></td>
<td align="left">WatchDog触发机制</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="noopener">理解Java Crash处理流程</a></td>
<td align="left">AMS.handleApplicationCrash过程分析</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/25/android-native-crash/" target="_blank" rel="noopener">理解Native Crash处理流程</a></td>
<td align="left">debuggerd守护进程</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2019/01/19/global_ref/" target="_blank" rel="noopener">global reference限制策略</a></td>
<td align="left">global reference</td>
</tr>
</tbody></table>
<h4 id="4-3-Android进程系列"><a href="#4-3-Android进程系列" class="headerlink" title="4.3 Android进程系列"></a>4.3 Android进程系列</h4><p>进程/线程是操作系统的魂，各种服务、组件、子系统都是依附于具体的进程实体。深入理解进程机制对于掌握Android系统整体架构和运转机制是非常有必要的，是系统工程师的基本功，下面列举进程相关的文章：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a></td>
<td align="left">Process.start过程分析</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/04/16/kill-signal/" target="_blank" rel="noopener">理解杀进程的实现原理</a></td>
<td align="left">Process.killProcess过程分析</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/10/09/app-process-create-2/" target="_blank" rel="noopener">Android四大组件与进程启动的关系</a></td>
<td align="left">AMS.startProcessLocked过程分析组件与进程</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/10/22/force-stop/" target="_blank" rel="noopener">Android进程绝杀技–forceStop</a></td>
<td align="left">force-stop过程分析彻底移除组件与杀进程</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/24/android-thread/" target="_blank" rel="noopener">理解Android线程创建流程</a></td>
<td align="left">3种不同线程的创建过程</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">彻底理解Android Binder通信架构</a></td>
<td align="left">以start-service为线,阐述进程间通信机理</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/10/29/binder-thread-pool/" target="_blank" rel="noopener">理解Binder线程池的管理</a></td>
<td align="left">Zygote fork的进程都默认开启binder线程池</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-lifecycle/" target="_blank" rel="noopener">Android进程生命周期与ADJ</a></td>
<td align="left">进程adj, processState以及lmk</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></td>
<td align="left">lmk原理分析</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2015/10/01/process-priority/" target="_blank" rel="noopener">进程优先级</a></td>
<td align="left">进程nice,thread priority以及scheduler</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2016/08/07/android-adj/" target="_blank" rel="noopener">Android进程调度之adj算法</a></td>
<td align="left">updateOomAdjLocked过程</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2015/12/19/android-process-category/" target="_blank" rel="noopener">Android进程整理</a></td>
<td align="left">整理系统的所有进程/线程</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2018/05/19/android-process-adj/" target="_blank" rel="noopener">解读Android进程优先级ADJ算法</a></td>
<td align="left">Android进程ADJ优先级</td>
</tr>
</tbody></table>
<h4 id="4-4-四大组件系列"><a href="#4-4-四大组件系列" class="headerlink" title="4.4 四大组件系列"></a>4.4 四大组件系列</h4><p>对于App来说，Android应用的四大组件Activity，Service，Broadcast Receiver， Content Provider最为核心，接下分别展开介绍：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/03/18/start-activity-cycle/" target="_blank" rel="noopener">简述Activity生命周期</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/03/06/start-service/" target="_blank" rel="noopener">startService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2016/05/01/bind-service/" target="_blank" rel="noopener">bindService启动过程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/09/04/binder-start-service/" target="_blank" rel="noopener">以Binder视角来看Service启动</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/06/04/broadcast-receiver/" target="_blank" rel="noopener">Android Broadcast广播机制分析</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/07/30/content-provider/" target="_blank" rel="noopener">理解ContentProvider原理</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/05/03/content_provider_release/" target="_blank" rel="noopener">ContentProvider引用计数</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2015/05/31/android-lifecycle/" target="_blank" rel="noopener">Activity与Service生命周期</a></td>
<td align="left">Activity&amp;&amp;Service</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2017/04/16/activity-with-window/" target="_blank" rel="noopener">简述Activity与Window关系</a></td>
<td align="left">Activity&amp;&amp;Window</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/05/19/ams-abstract/" target="_blank" rel="noopener">四大组件之综述</a></td>
<td align="left">AMS</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/05/25/service_record/" target="_blank" rel="noopener">四大组件之ServiceRecord</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><a href="http://gityuan.com/2017/06/03/broadcast_record/" target="_blank" rel="noopener">四大组件之BroadcastRecord</a></td>
<td align="left">Broadcast</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><a href="http://gityuan.com/2017/06/04/content_provider_record/" target="_blank" rel="noopener">四大组件之ContentProviderRecord</a></td>
<td align="left">ContentProvider</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a href="http://gityuan.com/2017/04/09/android_context/" target="_blank" rel="noopener">理解Android Context</a></td>
<td align="left">Context</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解Application创建过程</a></td>
<td align="left">Application</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a href="http://gityuan.com/2016/05/02/unbind-service/" target="_blank" rel="noopener">unbindService流程分析</a></td>
<td align="left">Service</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a href="http://gityuan.com/2017/06/11/activity_record/" target="_blank" rel="noopener">四大组件之ActivityRecord</a></td>
<td align="left">Activity</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a href="http://gityuan.com/2017/06/25/ams_summary_1/" target="_blank" rel="noopener">AMS总结(一)</a></td>
<td align="left">AMS</td>
</tr>
</tbody></table>
<h4 id="4-5-图形系统系列"><a href="#4-5-图形系统系列" class="headerlink" title="4.5 图形系统系列"></a>4.5 图形系统系列</h4><p>图形也是整个系统非常复杂且重要的一个系列，涉及WindowManager,SurfaceFlinger服务。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2017/01/08/windowmanger/" target="_blank" rel="noopener">WindowManager启动篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS之启动窗口篇</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2017/01/22/start-activity-wms/" target="_blank" rel="noopener">以Window视角来看startActivity</a></td>
<td align="left">Window</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2017/02/05/graphic_arch/" target="_blank" rel="noopener">Android图形系统概述</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2017/02/11/surface_flinger/" target="_blank" rel="noopener">SurfaceFlinger启动篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2017/02/18/surface_flinger_2/" target="_blank" rel="noopener">SurfaceFlinger绘图篇</a></td>
<td align="left">SurfaceFlinger</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2017/02/25/choreographer/" target="_blank" rel="noopener">Choreographer原理</a></td>
<td align="left">Choreographer</td>
</tr>
</tbody></table>
<h4 id="4-6-系统服务篇"><a href="#4-6-系统服务篇" class="headerlink" title="4.6 系统服务篇"></a>4.6 系统服务篇</h4><p>再则就是在整个架构中有大量的服务，都是基于<a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="noopener">Binder</a>来交互的，<a href="http://gityuan.com/2016/10/01/system_service_common/" target="_blank" rel="noopener">Android系统服务的注册过程</a>也是在此之上的构建的。计划针对部分核心服务来重点分析：</p>
<ul>
<li>AMS服务<ul>
<li><a href="http://gityuan.com/2016/02/21/activity-manager-service/" target="_blank" rel="noopener">AMS启动过程（一）</a></li>
<li>更多组件篇[见小节4.3]</li>
</ul>
</li>
<li>Input系统<ul>
<li><a href="http://gityuan.com/2016/12/10/input-manager/" target="_blank" rel="noopener">Input系统—启动篇</a></li>
<li><a href="http://gityuan.com/2016/12/11/input-reader/" target="_blank" rel="noopener">Input系统—InputReader线程</a></li>
<li><a href="http://gityuan.com/2016/12/17/input-dispatcher/" target="_blank" rel="noopener">Input系统—InputDispatcher线程</a></li>
<li><a href="http://gityuan.com/2016/12/24/input-ui/" target="_blank" rel="noopener">Input系统—UI线程</a></li>
<li><a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Input系统—进程交互</a></li>
<li><a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="noopener">Input系统—ANR原理分析</a></li>
</ul>
</li>
<li>PKMS服务<ul>
<li><a href="http://gityuan.com/2016/11/06/packagemanager" target="_blank" rel="noopener">PackageManager启动篇</a></li>
<li><a href="http://gityuan.com/2016/11/13/android-installd" target="_blank" rel="noopener">Installd守护进程</a></li>
</ul>
</li>
<li>Alarm服务<ul>
<li><a href="http://gityuan.com/2017/03/12/alarm_manager_service/" target="_blank" rel="noopener">理解AlarmManager机制</a></li>
</ul>
</li>
<li>JobScheduler服务<ul>
<li><a href="http://gityuan.com/2017/03/10/job_scheduler_service/" target="_blank" rel="noopener">理解JobScheduler机制</a></li>
</ul>
</li>
<li>BatteryService<ul>
<li><a href="http://gityuan.com/2016/01/10/power_rank/" target="_blank" rel="noopener">Android耗电统计算法</a></li>
</ul>
</li>
<li>PMS服务</li>
<li>DropBox服务<ul>
<li><a href="http://gityuan.com/2016/06/12/DropBoxManagerService/" target="_blank" rel="noopener">DropBoxManager启动篇</a></li>
</ul>
</li>
<li>UserManagerService<ul>
<li><a href="http://gityuan.com/2016/11/20/user_manager/" target="_blank" rel="noopener">多用户管理UserManager</a></li>
</ul>
</li>
<li>更多系统服务</li>
</ul>
<h4 id="4-7-内存-amp-amp-存储篇"><a href="#4-7-内存-amp-amp-存储篇" class="headerlink" title="4.7 内存&amp;&amp;存储篇"></a>4.7 内存&amp;&amp;存储篇</h4><ul>
<li>内存篇<ul>
<li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" target="_blank" rel="noopener">Android LowMemoryKiller原理分析</a></li>
<li><a href="http://gityuan.com/2015/10/30/kernel-memory/" target="_blank" rel="noopener">Linux内存管理</a></li>
<li><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></li>
</ul>
</li>
<li>存储篇<ul>
<li><a href="http://gityuan.com/2016/07/17/android-io/" target="_blank" rel="noopener">Android存储系统之源码篇</a></li>
<li><a href="http://gityuan.com/2016/07/23/android-io-arch" target="_blank" rel="noopener">Android存储系统之架构篇</a></li>
</ul>
</li>
<li>Linux驱动篇</li>
<li>dalvik/art<ul>
<li><a href="http://gityuan.com/2016/11/26/art-trace/" target="_blank" rel="noopener">解读Java进程的Trace文件</a></li>
</ul>
</li>
</ul>
<h4 id="4-8-工具篇"><a href="#4-8-工具篇" class="headerlink" title="4.8 工具篇"></a>4.8 工具篇</h4><p>再来说说Android相关的一些常用命令和工具以及调试手段.</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2016/03/19/android-build/" target="_blank" rel="noopener">理解Android编译命令</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2018/06/02/android-bp/" target="_blank" rel="noopener">理解Android.bp</a></td>
<td align="left">build</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2016/01/17/systrace/" target="_blank" rel="noopener">性能工具Systrace</a></td>
<td align="left">systrace</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="noopener">Android内存分析命令</a></td>
<td align="left">Memory</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2015/10/11/ps-command/" target="_blank" rel="noopener">ps进程命令</a></td>
<td align="left">Process</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2016/02/27/am-command/" target="_blank" rel="noopener">Am命令用法</a></td>
<td align="left">Am</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2016/02/28/pm-command/" target="_blank" rel="noopener">Pm命令用法</a></td>
<td align="left">Pm</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><a href="http://gityuan.com/2016/06/10/bugreport/" target="_blank" rel="noopener">调试系列1：bugreport源码篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><a href="http://gityuan.com/2016/06/11/bugreport-2/" target="_blank" rel="noopener">调试系列2：bugreport实战篇</a></td>
<td align="left">bugreport</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a href="http://gityuan.com/2016/05/14/dumpsys-command/" target="_blank" rel="noopener">dumpsys命令用法</a></td>
<td align="left">dumpsys</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a href="http://gityuan.com/2018/01/27/android-log/" target="_blank" rel="noopener">Android logd日志原理</a></td>
<td align="left">logd</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a href="http://gityuan.com/2017/09/09/gdb/" target="_blank" rel="noopener">介绍gdb调试工具</a></td>
<td align="left">gdb</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><a href="http://gityuan.com/2017/09/02/addr2line/" target="_blank" rel="noopener">介绍addr2line调试命令</a></td>
<td align="left">addr2line</td>
</tr>
</tbody></table>
<h4 id="4-9-实战篇"><a href="#4-9-实战篇" class="headerlink" title="4.9 实战篇"></a>4.9 实战篇</h4><p>下面列举处理过的部分较为典型的案例，供大家参考</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">文章名</th>
<th align="left">类别</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a href="http://gityuan.com/2018/05/12/binder-driver-bug/" target="_blank" rel="noopener">Binder Driver缺陷导致定屏的案例</a></td>
<td align="left">binder</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a href="http://gityuan.com/2019/01/13/arraymap/" target="_blank" rel="noopener">深度解读ArrayMap优势与缺陷</a></td>
<td align="left">ArrayMap</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a href="http://gityuan.com/2018/02/10/reboot-locked-method/" target="_blank" rel="noopener">数组越界导致系统重启的案例</a></td>
<td align="left">数组越界</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a href="http://gityuan.com/2018/02/03/log-fc/" target="_blank" rel="noopener">一行Log引发多线程并发问题的案例</a></td>
<td align="left">多线程并发</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a href="http://gityuan.com/2018/02/17/monkey-deadlock/" target="_blank" rel="noopener">跑monkey压力测试过程的冻屏案例</a></td>
<td align="left">monkey冻屏</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a href="http://gityuan.com/2018/02/24/process-keep-forever/" target="_blank" rel="noopener">深度剖析APP保活案例</a></td>
<td align="left">保活</td>
</tr>
</tbody></table>
<h3 id="五、结束语"><a href="#五、结束语" class="headerlink" title="五、结束语"></a>五、结束语</h3><p>Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。</p>
<p>再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行》里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。</p>
]]></content>
  </entry>
  <entry>
    <title>【转载】Dart虚拟机运行原理</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Dart%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="一、Dart虚拟机"><a href="#一、Dart虚拟机" class="headerlink" title="一、Dart虚拟机"></a>一、Dart虚拟机</h2><h4 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h4><p>Dart VM是一种虚拟机，为高级编程语言Dart提供执行环境，但这并意味着Dart在D虚拟机上执行时，总是采用解释执行或者JIT编译。 例如还可以使用Dart虚拟机的AOT管道将Dart代码编译为机器代码，然后运行在Dart虚拟机的精简版环境，称之为预编译运行时(precompiled runtime)环境，该环境不包含任何编译器组件，且无法动态加载Dart源代码。</p>
<h4 id="1-2-虚拟机如何运行Dart代码"><a href="#1-2-虚拟机如何运行Dart代码" class="headerlink" title="1.2 虚拟机如何运行Dart代码"></a>1.2 虚拟机如何运行Dart代码</h4><p>Dart VM有多钟方式来执行代码：</p>
<ul>
<li>源码或者Kernel二进制(JIT)</li>
<li>snapshot<ul>
<li>AOT snapshot</li>
<li>AppJIT snapshot</li>
</ul>
</li>
</ul>
<p>区别主要在于什么时机以及如何将Dart代码转换为可执行的代码。</p>
<h4 id="1-3-Isolate组成"><a href="#1-3-Isolate组成" class="headerlink" title="1.3 Isolate组成"></a>1.3 Isolate组成</h4><p>先来看看dart虚拟机中isolate的组成：</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/isolates.png" alt="img"></p>
<ul>
<li>isolate堆是运该isolate中代码分配的所有对象的GC管理的内存存储；</li>
<li>vm isolate是一个伪isolate，里面包含不可变对象，比如null，true，false；</li>
<li>isolate堆能引用vm isolate堆中的对象，但vm isolate不能引用isolate堆；</li>
<li>isolate彼此之间不能相互引用</li>
<li>每个isolate都有一个执行dart代码的Mutator thread，一个处理虚拟机内部任务(比如GC, JIT等)的helper thread；</li>
</ul>
<p>isolate拥有内存堆和控制线程，虚拟机中可以有很多isolate，但彼此之间不能直接状态，只能通过dart特有的端口；isolate除了拥有一个mutator控制线程，还有一些其他辅助线程：</p>
<ul>
<li>后台JIT编译线程；</li>
<li>GC清理线程；</li>
<li>GC并发标记线程；</li>
</ul>
<p>线程和isolate的关系是什么呢？</p>
<ul>
<li>同一个线程在同一时间只能进入一个isolate，当需要进入另一个isolate则必须先退出当前的isolate；</li>
<li>一次只能有一个Mutator线程关联对应的isolate，Mutator线程是执行Dart代码并使用虚拟机的公共的C语言API的线程</li>
</ul>
<h4 id="1-4-ThreadPool组成"><a href="#1-4-ThreadPool组成" class="headerlink" title="1.4 ThreadPool组成"></a>1.4 ThreadPool组成</h4><p>虚拟机采用线程池的方式来管理线程，定义在runtime/vm/thread_pool.h</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/ThreadPool.png" alt="img"></p>
<p>ThreadPool的核心成员变量：</p>
<ul>
<li>all_workers_：记录所有的workers；</li>
<li>idle_workers：_记录所有空闲的workers;</li>
<li>count_started_：记录该线程池的历史累计启动workers个数;</li>
<li>count_stopped_：记录该线程池的历史累计关闭workers个数；</li>
<li>count_running_：记录该线程池当前正在运行的worker个数；</li>
<li>count_idle_：记录该线程池当前处于空闲的worker个数，也就是idle_workers的长度；</li>
</ul>
<p>ThreadPool核心方法：</p>
<ul>
<li>Run(Task*): 执行count_running_加1，并将Task设置到该Worker，<ul>
<li>当idle_workers_为空，则创建新的Worker并添加到all_workers_队列头部，count_started_加1；</li>
<li>当idle_workers_不为空，则取走idle_workers_队列头部的Worker，count_idle_减1；</li>
</ul>
</li>
<li>Shutdown(): 将all_workers_和idle_workers_队列置为NULL，并将count_running_和count_idle_清零，将关闭的all_workers_个数累加到count_stopped_；</li>
<li>SetIdleLocked(Worker*)：将该Worker添加到idle_workers_队列头部，count_idle_加1， count_running_减1;</li>
<li>ReleaseIdleWorker(Worker*)：从all_workers_和idle_workers_队列中移除该Worker，count_idle_减1，count_stopped_加1；</li>
</ul>
<p>对应关系图：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">count_started_</th>
<th align="left">count_stopped_</th>
<th align="left">count_running_</th>
<th align="left">count_idle_</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Run()</td>
<td align="left">+1(无空闲worker)</td>
<td align="left"></td>
<td align="left">+1</td>
<td align="left">-1(有空闲worker)</td>
</tr>
<tr>
<td align="left">Shutdown()</td>
<td align="left"></td>
<td align="left">+all_workers_个数</td>
<td align="left">清零</td>
<td align="left">清零</td>
</tr>
<tr>
<td align="left">SetIdleLocked()</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">-1</td>
<td align="left">+1</td>
</tr>
<tr>
<td align="left">ReleaseIdleWorker()</td>
<td align="left"></td>
<td align="left">+1</td>
<td align="left"></td>
<td align="left">-1</td>
</tr>
</tbody></table>
<p>可见，count_started_ - count_stopped_ = count_running_ + count_idle_；</p>
<h2 id="二、JIT运行模式"><a href="#二、JIT运行模式" class="headerlink" title="二、JIT运行模式"></a>二、JIT运行模式</h2><h4 id="2-1-CFE前端编译器"><a href="#2-1-CFE前端编译器" class="headerlink" title="2.1 CFE前端编译器"></a>2.1 CFE前端编译器</h4><p>看看dart是如何直接理解并执行dart源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; gityuan.dart</span><br><span class="line">main() &#x3D;&gt; print(&#39;Hello Gityuan!&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dart位于flutter&#x2F;bin&#x2F;cache&#x2F;dart-sdk&#x2F;bin&#x2F;dart</span><br><span class="line">$ dart gityuan.dart</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>Dart虚拟机并不能直接从Dart源码执行，而是执行dill二进制文件，该二进制文件包括序列化的Kernel AST(抽象语法树)。</li>
<li>Dart Kernel是一种从Dart中衍生而来的高级语言，设计之初用于程序分析与转换(transformations)的中间产物，可用于代码生成与后端编译器，该kernel语言有一个内存表示，可以序列化为二进制或文本。</li>
<li>将Dart转换为Kernel AST的是CFE(common front-end）通用前端编译器。</li>
<li>生成的Kernel AST可交由Dart VM、dev_compiler以及dart2js等各种Dart工具直接使用。</li>
</ul>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/dart-to-kernel.png" alt="img"></p>
<h4 id="2-2-kernel-service"><a href="#2-2-kernel-service" class="headerlink" title="2.2 kernel service"></a>2.2 kernel service</h4><p>有一个辅助类isolate叫作kernel service，其核心工作就是CFE，将dart转为Kernel二进制，然后VM可直接使用Kernel二进制运行在主isolate里面运行。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/kernel-service.png" alt="img"></p>
<h4 id="2-3-debug运行"><a href="#2-3-debug运行" class="headerlink" title="2.3 debug运行"></a>2.3 debug运行</h4><p>将dart代码转换为kernel二进制和执行kernel二进制，这两个过程也可以分离开来，在两个不同的机器执行，比如host机器执行编译，移动设备执行kernel文件。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/flutter-cfe.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>这个编译过程并不是flutter tools自身完成，而是交给另一个进程frontend_server来执行，它包括CFE和一些flutter专有的kernel转换器。</li>
<li>hot reload：热重载机制正是依赖这一点，frontend_server重用上一次编译中的CFE状态，只重新编译实际更改的部分。</li>
</ul>
<h4 id="2-4-RawClass内部结构"><a href="#2-4-RawClass内部结构" class="headerlink" title="2.4 RawClass内部结构"></a>2.4 RawClass内部结构</h4><p>虚拟机内部对象的命名约定：使用C++定义的，其名称在头文件raw_object.h中以Raw开头，比如RawClass是描述Dart类的VM对象，RawField是描述Dart类中的Dart字段的VM对象。</p>
<p>1）将内核二进制文件加载到VM后，将对其进行解析以创建表示各种程序实体的对象。这里采用了懒加载模式，一开始只有库和类的基本信息被加载，内核二进制文件中的每一个实体都会保留指向该二进制文件的指针，以便后续可根据需要加载更多信息。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/kernel-loaded-1.png" alt="img"></p>
<p>2）仅在以后需要运行时，才完全反序列化有关类的信息。（例如查找类的成员变量，创建类的实例对象等），便会从内核二进制文件中读取类的成员信息。 但功能完整的主体(FunctionNode)在此阶段并不会反序列化，而只是获取其签名。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/kernel-loaded-2.png" alt="img"></p>
<p>到此，已从内核二进制文件加载了足够的信息以供运行时成功解析和调用的方法。</p>
<p>所有函数的主体都具有占位符code_，而不是实际的可执行代码：它们指向LazyCompileStub，该Stub只是简单地要求系统Runtime为当前函数生成可执行代码，然后对这些新生成的代码进行尾部调用。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/raw-function-lazy-compile.png" alt="img"></p>
<h4 id="2-5-查看Kernel文件格式"><a href="#2-5-查看Kernel文件格式" class="headerlink" title="2.5 查看Kernel文件格式"></a>2.5 查看Kernel文件格式</h4><p>gen_kernel.dart利用CFE将Dart源码编译为kernel binary文件(也就是dill)，可利用dump_kernel.dart能反解kernel binary文件，命令如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将hello.dart编译成hello.dill</span></span><br><span class="line">$ cd &lt;FLUTTER_ENGINE_ROOT&gt;</span><br><span class="line">$ dart third_party/dart/pkg/vm/bin/gen_kernel.dart          \</span><br><span class="line">       --platform out/android_debug/vm_platform_strong.dill \</span><br><span class="line">       -o hello.dill                                        \</span><br><span class="line">       hello.dart</span><br><span class="line"></span><br><span class="line"><span class="comment">//转储AST的文本表示形式</span></span><br><span class="line">$ dart third_party/dart/pkg/vm/bin/dump_kernel.dart hello.dill hello.kernel.txt</span><br></pre></td></tr></table></figure>

<p>gen_kernel.dart文件，需要平台dill文件，这是一个包括所有核心库(dart:core, dart:async等)的AST的kernel binary文件。如果Dart SDK已经编译过，可直接使用out/ReleaseX64/vm_platform_strong.dill，否则需要使用compile_platform.dart来生成平台dill文件，如下命令:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据给定的库列表，来生成platform和outline文件</span></span><br><span class="line">$ cd &lt;FLUTTER_ENGINE_ROOT&gt;</span><br><span class="line">$ dart third_party/dart/pkg/front_end/tool/_fasta/compile_platform.dart \</span><br><span class="line">       dart:core                                                        \        </span><br><span class="line">       third_party/dart/sdk/lib/libraries.json                          \</span><br><span class="line">       vm_outline.dill vm_platform.dill vm_outline.dill</span><br></pre></td></tr></table></figure>

<h4 id="2-6-未优化编译器"><a href="#2-6-未优化编译器" class="headerlink" title="2.6 未优化编译器"></a>2.6 未优化编译器</h4><p>首次编译函数时，这是通过未优化编译器来完成的。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/unoptimized-compilation.png" alt="img"></p>
<p>未优化的编译器分两步生成机器代码：</p>
<ul>
<li>AST -&gt; CFG: 对函数主体的序列化AST进行遍历，以生成函数主体的控制流程图(CFG)，CFG是由填充中间语言（IL）指令的基本块组成。此阶段使用的IL指令类似于基于堆栈的虚拟机的指令：它们从堆栈中获取操作数，执行操作，然后将结果压入同一堆栈</li>
<li>IL -&gt; 机器指令：使用一对多的IL指令，将生成的CFG直接编译为机器代码：每个IL指令扩展为多条机器指令。</li>
</ul>
<p>在此阶段没有执行优化，未优化编译器的主要目标是快速生成可执行代码。</p>
<h4 id="2-7-内联缓存"><a href="#2-7-内联缓存" class="headerlink" title="2.7 内联缓存"></a>2.7 内联缓存</h4><p>未优化编译过程，编译器不会尝试静态解析任何未在Kernel二进制文件中解析的调用，因此（MethodInvocation或PropertyGet AST节点）的调用被编译为完全动态的。虚拟机当前不使用任何形式的基于虚拟表(virtual table)或接口表(interface table)的调度，而是使用内联缓存实现动态调用。</p>
<p>虚拟机的内联缓存的核心思想是缓存方法解析后的站点结果信息，对于内联缓存最初是为了解决函数的本地代码：</p>
<ul>
<li>站点调用的特定缓存(RawICData对象)将接受者的类映射到方法，缓存中记录着一些辅助信息，比如方法和基本块的调用频次计数器，该计数器记录着被跟踪类的调用频次；</li>
<li>共享的查找存根，用于实现方法调用的快速路径。该存根在给定的高速缓存中进行搜索，以查看其是否包含与接收者的类别匹配的条目。 如果找到该条目，则存根将增加频率计数器和尾部调用缓存的方法。否则，存根将调用系统Runtime来解析方法实现的逻辑，如果方法解析成功，则将更新缓存，并且随后的调用无需进入系统Runtime。</li>
</ul>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/inline-cache-1.png" alt="img"></p>
<h4 id="2-8-编译优化"><a href="#2-8-编译优化" class="headerlink" title="2.8 编译优化"></a>2.8 编译优化</h4><p>未优化编译器产生的代码执行比较慢，需要自适应优化，通过profile配置文件来驱动优化策略。内联优化，当与某个功能关联的执行计数器达到某个阈值时，该功能将提交给后台优化编译器进行优化。</p>
<p>优化编译的方式与未优化编译的方式相同：通过序列化内核AST来构建未优化的IL。但是，优化编译器不是直接将IL编译为机器码，而是将未优化的IL转换为基于静态单分配（SSA）形式的优化的IL。</p>
<p>对基于SSA的IL通过基于收集到的类型反馈，内联，范围分析，类型传播，表示选择，存储到加载，加载到加载转发，全局值编号，分配接收等一系列经典和Dart特定的优化来进行专业化推测。最后，使用线性扫描寄存器分配器和一个简单的一对多的IL指令。优化编译完成后，后台编译器会请求mutator线程输入安全点，并将优化的代码附加到该函数。下次调用该函数时，它将使用优化的代码。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/optimizing-compilation.png" alt="img"></p>
<p>另外，有些函数包含很长的运行循环，因此在函数仍在运行时将执行从未优化的代码切换到优化的代码是有意义的，此过程之所以称为“堆栈替换”（OSR）。</p>
<p>VM还具有可用于控制JIT并使其转储IL以及用于JIT正在编译的功能的机器代码的标志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ dart --print-flow-graph-optimized         \</span><br><span class="line">       --disassemble-optimized              \</span><br><span class="line">       --print-flow-graph-filter=myFunc     \</span><br><span class="line">       --no-background-compilation          \</span><br><span class="line">       hel.dart</span><br></pre></td></tr></table></figure>

<h4 id="2-9-反优化"><a href="#2-9-反优化" class="headerlink" title="2.9 反优化"></a>2.9 反优化</h4><p>优化是基于统计的，可能出现违反优化的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAnimal</span><span class="params">(obj)</span> </span>&#123;</span><br><span class="line">  print(<span class="string">'Animal &#123;'</span>);</span><br><span class="line">  print(<span class="string">'  $&#123;obj.toString()&#125;'</span>);</span><br><span class="line">  print(<span class="string">'&#125;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大量调用的情况下，会推测printAnimal假设总是Cat的情况下来优化代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">  printAnimal(Cat());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处出现的是Dog，优化版本失效，则触发反优化</span></span><br><span class="line">printAnimal(Dog());</span><br></pre></td></tr></table></figure>

<p>每当只要优化版本遇到无法解决的情况，它就会将执行转移到未优化功能的匹配点，然后继续执行，这个恢复过程称为去优化：未优化的功能版本不做任何假设，可以处理所有可能的输入。</p>
<p>虚拟机通常会在执行一次反优化后，放弃该功能的优化版本，然后在以后使用优化的类型反馈再次对其进行重新优化。虚拟机保护编译器进行推测性假设的方式有两种：</p>
<ul>
<li>内联检查（例如CheckSmi，CheckClass IL指令），以验证假设是否在编译器做出此假设的使用场所成立。例如，将动态调用转换为直接调用时，编译器会在直接调用之前添加这些检查。 在此类检查中发生的取消优化称为“急切优化”，因为它在达到检查时就急于发生。</li>
<li>运行时在更改优化代码所依赖的内容时，将会丢弃优化代码。例如，优化编译器可能会发现某些类从未扩展过，并且在类型传播过程中使用了此信息。 但是，随后的动态代码加载或类最终确定可能会引入C的子类，导致假设无效。此时，运行时需要查找并丢弃所有在C没有子类的假设下编译的优化代码。 运行时可能会在执行堆栈上找到一些现在无效的优化代码，在这种情况下，受影响的帧将被标记为不优化，并且当执行返回时将进行不优化。 这种取消优化称为延迟取消优化，因为它会延迟到控制权返回到优化代码为止。</li>
</ul>
<h2 id="三、Snapshots运行模式"><a href="#三、Snapshots运行模式" class="headerlink" title="三、Snapshots运行模式"></a>三、Snapshots运行模式</h2><h3 id="3-1-通过Snapshots运行"><a href="#3-1-通过Snapshots运行" class="headerlink" title="3.1 通过Snapshots运行"></a>3.1 通过Snapshots运行</h3><p>1）虚拟机有能力将isolate的堆（驻留在堆上的对象图）序列化成二进制的快照，启动虚拟机isolate的时候可以从快照中重新创建相同的状态。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/snapshot.png" alt="img"></p>
<p>Snapshot的格式是低级的，并且针对快速启动进行了优化，本质上是要创建的对象列表以及如何将它们连接在一起的说明。那是快照背后的原始思想：代替解析Dart源码并逐步创建虚拟机内部的数据结构，这样虚拟机通过快照中的所有必要数据结构来快速启动isolate。</p>
<p>2）最初，快照不包括机器代码，但是后来在开发AOT编译器时添加了此功能。开发AOT编译器和带代码快照的动机是为了允许虚拟机在由于平台级别限制而无法进行JIT的平台上使用。</p>
<p>带代码的快照的工作方式几乎与普通快照相同，只是有一点点不同：它们包括一个代码部分，该部分与快照的其余部分不同，不需要反序列化。该代码节的放置方式使其可以在映射到内存后直接成为堆的一部分</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/snapshot-with-code.png" alt="img"></p>
<h3 id="3-2-通过AppJIT-Snapshots运行"><a href="#3-2-通过AppJIT-Snapshots运行" class="headerlink" title="3.2 通过AppJIT Snapshots运行"></a>3.2 通过AppJIT Snapshots运行</h3><p>引入AppJIT快照可减少大型Dart应用程序（如dartanalyzer或dart2js）的JIT预热时间。当这些工具用于小型项目时，它们花费的实际时间与VM花费的JIT编译这些应用程序的时间一样多。</p>
<p>AppJIT快照可以解决此问题：可以使用一些模拟训练数据在VM上运行应用程序，然后将所有生成的代码和VM内部数据结构序列化为AppJIT快照。然后可以分发此快照，而不是以源（或内核二进制）形式分发应用程序。如果出现实际数据上的执行配置文件与培训期间观察到的执行配置文件不匹配，快照开始的VM仍可以采用JIT模式执行。</p>
<h3 id="3-3-通过AppAOT-Snapshots运行"><a href="#3-3-通过AppAOT-Snapshots运行" class="headerlink" title="3.3 通过AppAOT Snapshots运行"></a>3.3 通过AppAOT Snapshots运行</h3><p>AOT快照最初是为无法进行JIT编译的平台引入的，对于无法进行JIT意味着：</p>
<ul>
<li>AOT快照必须包含应用程序执行期间可能调用的每个功能的可执行代码;</li>
<li>可执行代码不得依赖于执行期间可能违反的任何推测性假设</li>
</ul>
<p>为了满足这些要求，AOT编译过程会进行全局静态分析（类型流分析, TFA），以确定从已知入口点集中可访问应用程序的哪些部分，分配了哪些类的实例以及类型如何在程序中流动。 所有这些分析都是保守的：这意味着它们会在正确性方面出错，与可以在性能方面出错的JIT形成鲜明对比，因为它始终可以取消优化为未优化的代码以实现正确的行为。</p>
<p>然后，所有可能达到的功能都将编译为本地代码，而无需进行任何推测性优化。但是，类型流信息仍用于专门化代码（例如，取消虚拟化调用），编译完所有函数后，即可获取堆的快照。</p>
<p>最终的快照snapshot可以运行在预编译Runtime，该Runtime是Dart VM的特殊变体，其中不包括诸如JIT和动态代码加载工具之类的组件。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot.png" alt="img"></p>
<p>AOT编译工具没有包含进Dart SDK。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要构建正常的dart可执行文件和运行AOT代码的runtime</span></span><br><span class="line">$ tool/build.py -m release -a x64 runtime dart_precompiled_runtime</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用AOT编译器来编译APP</span></span><br><span class="line">$ pkg/vm/tool/precompiler2 hello.dart hello.aot</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行AOT快照</span></span><br><span class="line">$ out/ReleaseX64/dart_precompiled_runtime hello.aot</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<h4 id="3-3-1-Switchable-Calls"><a href="#3-3-1-Switchable-Calls" class="headerlink" title="3.3.1 Switchable Calls"></a>3.3.1 Switchable Calls</h4><p>1）即使进行了全局和局部分析，AOT编译的代码仍可能包含无法静态的去虚拟化的调用站点。为了补偿此AOT编译代码和运行时，采用JIT中使用的内联缓存技术的扩展。此扩展版本称为可切换呼叫 （Switchable Calls）。</p>
<p>JIT部分已经描述过，与调用站点关联的每个内联缓存均由两部分组成：一个缓存对象（由RawICData实例表示）和一个要调用的本机代码块（例如InlineCacheStub）。在JIT模式下，运行时只会更新缓存本身。但在AOT运行时中，可以根据内联缓存的状态选择同时替换缓存和要调用的本机代码。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot-ic-unlinked.png" alt="img"></p>
<p>最初，所有动态呼叫均以未链接状态开始。首次调用此类呼叫站点时，将调用UnlinkedCallStub，它只是调用运行时帮助程序DRT_UnlinkedCall来链接此呼叫站点。</p>
<p>2）如果可能，DRT_UnlinkedCall尝试将呼叫站点转换为单态状态。在这种状态下，呼叫站点变成直接呼叫，该呼叫通过特殊的单态入口点进入方法，该入口点验证接收方是否具有预期的类。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot-ic-monomorphic.png" alt="img"></p>
<p>在上面的示例中，假设第一次执行obj.method（）时，obj是C的实例，而obj.method则解析为C.method。</p>
<p>下次执行相同的调用站点时，它将直接调用C.method，从而绕过任何类型的方法查找过程。但是，它将通过特殊的入口点(已验证obj仍然是C的实例)进入C.method。如果不是这种情况，将调用DRT_MonomorphicMiss并将尝试选择下一个调用站点状态。</p>
<p>3）C.method可能仍然是调用的有效目标，例如obj是C的扩展类但不覆盖C.method的D类的实例。在这种情况下，检查呼叫站点是否可以转换为由SingleTargetCallStub实现的单个目标状态（见RawSingleTargetCache）。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot-ic-singletarget.png" alt="img"></p>
<p>此存根基于以下事实：对于AOT编译，大多数类都使用继承层次结构的深度优先遍历来分配整数ID。如果C是具有D0，…，Dn子类的基类，并且没有一个覆盖C.method，则C.:cid &lt;= classId（obj）&lt;= max（D0.:cid，…，Dn .:cid）表示obj.method解析为C.method。在这种情况下，我们可以将类ID范围检查（单个目标状态）用于C的所有子类，而不是与单个类（单态）进行比较</p>
<p>否则，呼叫站点将切换为使用线性搜索内联缓存，类似于在JIT模式下使用的缓存。</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot-ic-linear.png" alt="img"></p>
<p>最后，如果线性数组中的检查数量超过阈值，则呼叫站点将切换为使用类似字典的结构</p>
<p><img src="http://gityuan.com/img/dart_vm/vm_run/aot-ic-dictionary.png" alt="img"></p>
<h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><h4 id="4-1-源码说明"><a href="#4-1-源码说明" class="headerlink" title="4.1 源码说明"></a>4.1 源码说明</h4><p>整个过程相关的核心源码，简要说明：</p>
<ul>
<li>runtime/vm/isolate.h： isolate对象</li>
<li>runtime/vm/thread.h：与连接到isolate对象的线程关联的状态</li>
<li>runtime/vm/heap/heap.h： isolate的堆</li>
<li>raw_object.h： 虚拟机内部对象</li>
<li>ast.dart：定义描述内核AST的类</li>
<li>kernel_loader.cc：其中的LoadEntireProgram()方法用于将内核AST反序列化为相应虚拟机对象的入口点</li>
<li>kernel_service.dart：实现了Kernel Service isolate</li>
<li>kernel_isolate.cc：将Dart实现粘合到VM的其余部分</li>
<li>pkg/front_end：用于解析Dart源码和构建内核AST</li>
<li>pkg/vm: 托管了大多数基于内核的VM特定功能，例如各种内核到内核的转换；由于历史原因，某些转换还位于pkg/kernel;</li>
<li>runtime/vm/compiler: 编译器源码</li>
<li>runtime/vm/compiler/jit/compiler.cc：编译管道入口点</li>
<li>runtime/vm/compiler/backend/il.h： IL的定义</li>
<li>runtime/vm/compiler/frontend/kernel_binary_flowgraph.cc： 其中的BuildGraph(), 内核到IL的翻译开始，处理各种人工功能的IL的构建</li>
<li>runtime/vm/stub_code_x64.cc：其中StubCode::GenerateNArgsCheckInlineCacheStub()，为内联缓存存根生成机器代码</li>
<li>runtime/vm/runtime_entry.cc：其中InlineCacheMissHandler()处理IC没有命中的情况</li>
<li>runtime/vm/compiler/compiler_pass.cc: 定义优化编译器的遍历及其顺序</li>
<li>runtime/vm/compiler/jit/jit_call_specializer.h：进行大多数基于类型反馈的专业化</li>
<li>runtime/vm/deopt_instructions.cc： 反优化过程</li>
<li>runtime/vm/clustered_snapshot.cc：处理快照的序列化和反序列化。API函数家族Dart_CreateXyzSnapshot[AsAssembly]负责写出堆的快照，比如 Dart_CreateAppJITSnapshotAsBlobs 和Dart_CreateAppAOTSnapshotAsAssembly。</li>
<li>runtime/vm/dart_api_impl.cc： 其中Dart_CreateIsolate可以选择获取快照数据以开始isolate。</li>
<li>pkg/vm/lib/transformations/type_flow/transformer.dart: TFA（类型流分析）以及基于TFA结果转换的切入点</li>
<li>runtime/vm/compiler/aot/precompiler.cc：其中Precompiler::DoCompileAll()是整个AOT编译的切入点</li>
</ul>
<h4 id="4-2-参考资料"><a href="#4-2-参考资料" class="headerlink" title="4.2 参考资料"></a>4.2 参考资料</h4><p><a href="https://mrale.ph/dartvm/" target="_blank" rel="noopener">https://mrale.ph/dartvm/</a></p>
]]></content>
  </entry>
  <entry>
    <title>【转载】搭建Flutter Engine源码编译环境</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%90%AD%E5%BB%BAFlutter%20Engine%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="一、准备环境"><a href="#一、准备环境" class="headerlink" title="一、准备环境"></a>一、准备环境</h2><h4 id="1-1-准备"><a href="#1-1-准备" class="headerlink" title="1.1 准备"></a>1.1 准备</h4><ul>
<li>OS：MacOS同时支持Android和iOS的交叉编译功能，Linux只支持Android产物的交叉编译；</li>
<li>git：用于源码的版本控制;</li>
<li>ssh client：用于Github的认证;</li>
<li>IDE: <a href="https://flutter.dev/docs/development/tools/android-studio" target="_blank" rel="noopener">带有Flutter插件的Android Studio</a>，这是官方推荐的旗舰IDE;</li>
<li>depot_tools：内含gclient命令；</li>
<li>Python: 很多工具都需要用到Python，比如gclient;</li>
<li>JDK：Java开发工具;</li>
</ul>
<h4 id="1-2-安装depot-tools"><a href="#1-2-安装depot-tools" class="headerlink" title="1.2 安装depot_tools"></a>1.2 安装depot_tools</h4><p>1)克隆depot_tools仓库， 获取gclient命令，执行如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//chromium.googlesource.com/chromium/tools/depot_tools.git</span></span><br></pre></td></tr></table></figure>

<p>2) 设置环境变量，编辑 ~/.bashrc或者 ~/.zshrc，添加如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> PATH=$PATH:/path/to/depot_tools</span><br></pre></td></tr></table></figure>

<h4 id="1-3-安装Homebrew"><a href="#1-3-安装Homebrew" class="headerlink" title="1.3 安装Homebrew"></a>1.3 安装Homebrew</h4><p>打开终端，输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-安装ant和ninja"><a href="#1-4-安装ant和ninja" class="headerlink" title="1.4 安装ant和ninja"></a>1.4 安装ant和ninja</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install ant</span><br><span class="line">brew install ninja</span><br></pre></td></tr></table></figure>

<h2 id="二、引擎代码下载"><a href="#二、引擎代码下载" class="headerlink" title="二、引擎代码下载"></a>二、引擎代码下载</h2><p>Step 1: 创建名为engine的空文件夹;<br>Step 2: 在engine目录下新建.gclient配置文件，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solutions &#x3D; [</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;managed&quot;: False,</span><br><span class="line">    &quot;name&quot;: &quot;src&#x2F;flutter&quot;,</span><br><span class="line">    &#x2F;&#x2F;此处url需改为真实的个人或者公司引擎地址</span><br><span class="line">    &quot;url&quot;: &quot;git@github.com:&lt;your_name_here&gt;&#x2F;engine.git&quot;,</span><br><span class="line">    &quot;custom_deps&quot;: &#123;&#125;,</span><br><span class="line">    &quot;deps_file&quot;: &quot;DEPS&quot;,</span><br><span class="line">    &quot;safesync_url&quot;: &quot;&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Step 3. 拉取flutter引擎以及相关依赖</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd engine</span><br><span class="line">gclient sync  <span class="comment">//拉取Flutter引擎所有依赖的关联库</span></span><br></pre></td></tr></table></figure>

<p>gclient执行完成后，获取flutter引擎的源码目录结构如下所示：</p>
<p><img src="http://gityuan.com/img/flutter_engine_env/flutter_engine_src.png" alt="flutter_engine_src"></p>
<ul>
<li>src/flutter是引擎所对应的源码；</li>
<li>src/third_party是引擎所需要的三方库，包括dart, skia, libcxx等三方库</li>
</ul>
<h2 id="三、-引擎代码编译"><a href="#三、-引擎代码编译" class="headerlink" title="三、 引擎代码编译"></a>三、 引擎代码编译</h2><h4 id="3-1-编译Android引擎"><a href="#3-1-编译Android引擎" class="headerlink" title="3.1 编译Android引擎"></a>3.1 编译Android引擎</h4><p><strong>Step 1: 准备构建文件</strong><br>执行./flutter/tools/gn命令会在src/out目录下生成相应的文件夹，用于存放该平台的编译产物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd src  <span class="comment">//进入src目录</span></span><br><span class="line">./flutter/tools/gn --runtime-mode profile <span class="comment">//生成Host编译产物存放文件</span></span><br><span class="line">./flutter/tools/gn --android --runtime-mode profile <span class="comment">//生成Android编译产物存放文件</span></span><br></pre></td></tr></table></figure>

<p><img src="http://gityuan.com/img/flutter_engine_env/gn_cmd_help.png" alt="gn_cmd_help"></p>
<p>gn参数说明：</p>
<ul>
<li>unoptimized：是否优化性能，加上该参数则意味着运行性能会降低，但会大幅度提升编译速度</li>
<li>runtime-mode：制定Flutter的运行模式，可取值{debug,profile,release}；</li>
<li>android-cpu: 指定Android产物所运行的平台，可取值{arm,x64,x86,arm64}</li>
<li>ios-cpu: 指定iOS产物所运行的平台，可取值{arm,arm64}</li>
</ul>
<p><strong>Step 2: 构建可执行文件</strong><br>执行ninja命令，开始真正的构建过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ninja -C out/host_profile -j <span class="number">6</span></span><br><span class="line">ninja -C out/android_profile -j <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>构造Android或者iOS引擎版本，需要同步构建一个相应版本的host。比如使用android_debug_unopt，则需要同时构建host_debug_unopt；</li>
<li>-C：紧跟着的参数便是gn命令所生成的目录路径</li>
<li>-j：指定并发编译的进程个数，该值不宜超过PC的CPU核数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也支持同时执行多个ninja任务</span></span><br><span class="line">ninja -C out/host_profile &amp;&amp; ninja -C out/android_profile -j <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-编译iOS引擎"><a href="#3-2-编译iOS引擎" class="headerlink" title="3.2 编译iOS引擎"></a>3.2 编译iOS引擎</h4><p><strong>Step 1: 准备构建文件</strong><br>执行./flutter/tools/gn命令会在src/out目录下生成相应的文件夹，用于存放该平台的编译产物。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cd src  <span class="comment">//进入src目录</span></span><br><span class="line">./flutter/tools/gn --runtime-mode profile <span class="comment">//生成Host编译产物存放文件</span></span><br><span class="line">./flutter/tools/gn --ios --runtime-mode profile <span class="comment">//生成iOS编译产物存放文件</span></span><br></pre></td></tr></table></figure>

<p><strong>Step 2: 构建可执行文件</strong><br>执行ninja命令，开始真正的构建过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ninja -C out/host_profile -j <span class="number">6</span></span><br><span class="line">ninja -C out/ios_profile -j <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-使用本地引擎运行Flutter应用"><a href="#3-3-使用本地引擎运行Flutter应用" class="headerlink" title="3.3 使用本地引擎运行Flutter应用"></a>3.3 使用本地引擎运行Flutter应用</h4><p><strong>1) 构建本地引擎后，使用以下命令运行Flutter应用：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flutter run --local-engine-src-path &lt;FLUTTER_ENGINE_ROOT&gt;/engine/src --local-engine=android_profile</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>local-engine-src-path：指定Flutter引擎存储库的路径，也就是src根目录的绝对路径</li>
<li>local-engine：指定使用哪个引擎版本，比如android_profile</li>
</ul>
<p>这一点非常重要：使用保存有host_xxx引擎构建版本，当使用本地引擎，因为Flutter使用host构建版本中的dart，这是flutter tools会自动在host中寻找。</p>
<p><strong>2) 修改Dart文件:</strong></p>
<p>当引擎中修改了Dart源代码，则需要在pubspec.yaml中添加dependency_overrides部分，指定新的sky_engine和sky_services路径，以用于使用自定义引擎的flutter应用程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dependency_overrides:</span><br><span class="line">  sky_engine:</span><br><span class="line">    path: &lt;FLUTTER_ENGINE_ROOT&gt;/engine/src/out/host_profile/gen/dart-pkg/sky_engine</span><br><span class="line">  sky_services:</span><br><span class="line">    path: &lt;FLUTTER_ENGINE_ROOT&gt;/engine/src/out/host_profile/gen/dart-pkg/sky_services</span><br></pre></td></tr></table></figure>

<h4 id="3-4-IDE配置"><a href="#3-4-IDE配置" class="headerlink" title="3.4 IDE配置"></a>3.4 IDE配置</h4><p>推荐用Clion，查看C++代码比较方便。</p>
<ul>
<li>先使用./flutter/tools/gn编译引擎后，会在src/out目录下生成compile_commands.json 文件，Clion通过该文件可完成C++源码的方法跳转功能</li>
<li>进入src/flutter目录，将 compile_commands.json 软连接到 flutter 目录，或者直接拷贝到该目录；</li>
<li>使用Clion打开 src/flutter 目录，则能识别到compile_commands.json，可以开始阅读源码了；</li>
</ul>
<p>如果还是没有代码跳转的能力，则用clion的open,直接选中compile_commands.json打开。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/Compiling-the-engine" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Compiling-the-engine</a></li>
<li><a href="https://github.com/flutter/flutter/wiki/The-flutter-tool" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/The-flutter-tool</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>【转载】Android进程绝杀技--forceStop</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Android%E8%BF%9B%E7%A8%8B%E7%BB%9D%E6%9D%80%E6%8A%80--forceStop/</url>
    <content><![CDATA[<blockquote>
<p>基于Android 6.0源码剖析，force-stop的全过程</p>
</blockquote>
<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><h3 id="1-1-引言"><a href="#1-1-引言" class="headerlink" title="1.1 引言"></a>1.1 引言</h3><p>话说Android开源系统拥有着App不计其数，百家争鸣，都想在这“大争之世”寻得系统存活的一席之地。然则系统资源有限，如若都割据为王，再强劲的CPU也会忙不过来，再庞大的内存终会消耗殆尽，再大容量的电池续航终会昙花一现。</p>
<p>面对芸芸众生，无尽变数，系统以不变应万变，一招绝杀神技forceStop腾空出世，此处以adb指令的方式为例来说说其内部机理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am force-stop pkgName</span><br><span class="line">am force-stop --user 2 pkgName &#x2F;&#x2F;只杀用户userId&#x3D;2的相关信息</span><br></pre></td></tr></table></figure>

<p>force-stop命令杀掉所有用户空间下的包名pkgName相关的信息，也可以通过<code>--user</code>来指定用户Id。 当执行上述am指令时，则会触发调用Am.java的main()方法，接下来从main方法开始说起。</p>
<h3 id="1-2-Am-main"><a href="#1-2-Am-main" class="headerlink" title="1.2 Am.main"></a>1.2 Am.main</h3><p>[-&gt; Am.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     (new Am()).run(args); &#x2F;&#x2F;【见小节1.3】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Am-run"><a href="#1-3-Am-run" class="headerlink" title="1.3 Am.run"></a>1.3 Am.run</h3><p>[-&gt; Am.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mArgs &#x3D; args;</span><br><span class="line">    mNextArg &#x3D; 0;</span><br><span class="line">    mCurArgData &#x3D; null;</span><br><span class="line">    onRun(); &#x2F;&#x2F;【见小节1.4】</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-Am-onRun"><a href="#1-4-Am-onRun" class="headerlink" title="1.4 Am.onRun"></a>1.4 Am.onRun</h3><p>[-&gt; Am.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void onRun() throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;获取的是Binder proxy对象AMP</span><br><span class="line">    mAm &#x3D; ActivityManagerNative.getDefault();</span><br><span class="line">    String op &#x3D; nextArgRequired();</span><br><span class="line"></span><br><span class="line">    if (op.equals(&quot;start&quot;)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else if (op.equals(&quot;force-stop&quot;)) &#123;</span><br><span class="line">        runForceStop(); &#x2F;&#x2F;【见小节1.5】</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-Am-runForceStop"><a href="#1-5-Am-runForceStop" class="headerlink" title="1.5 Am.runForceStop"></a>1.5 Am.runForceStop</h3><p>[-&gt; Am.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void runForceStop() throws Exception &#123;</span><br><span class="line">    int userId &#x3D; UserHandle.USER_ALL;</span><br><span class="line"></span><br><span class="line">    String opt;</span><br><span class="line">    &#x2F;&#x2F; 当指定用户时，则解析相应userId</span><br><span class="line">    while ((opt&#x3D;nextOption()) !&#x3D; null) &#123;</span><br><span class="line">        if (opt.equals(&quot;--user&quot;)) &#123;</span><br><span class="line">            userId &#x3D; parseUserArg(nextArgRequired());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;【见小节1.6】</span><br><span class="line">    mAm.forceStopPackage(nextArgRequired(), userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不指定userId时，则默认为UserHandle.USER_ALL。</p>
<h3 id="1-6-AMP-forceStopPackage"><a href="#1-6-AMP-forceStopPackage" class="headerlink" title="1.6 AMP.forceStopPackage"></a>1.6 AMP.forceStopPackage</h3><p>[-&gt; ActivityManagerNative.java ::AMP]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void forceStopPackage(String packageName, int userId) throws RemoteException &#123;</span><br><span class="line">     Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">     Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">     data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">     data.writeString(packageName);</span><br><span class="line">     data.writeInt(userId);</span><br><span class="line">     &#x2F;&#x2F;【见小节1.7】</span><br><span class="line">     mRemote.transact(FORCE_STOP_PACKAGE_TRANSACTION, data, reply, 0);</span><br><span class="line">     reply.readException();</span><br><span class="line">     data.recycle();</span><br><span class="line">     reply.recycle();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-AMN-onTransact"><a href="#1-7-AMN-onTransact" class="headerlink" title="1.7 AMN.onTransact"></a>1.7 AMN.onTransact</h3><p>[-&gt; ActivityManagerNative.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">      case FORCE_STOP_PACKAGE_TRANSACTION: &#123;</span><br><span class="line">           data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">           String packageName &#x3D; data.readString();</span><br><span class="line">           int userId &#x3D; data.readInt();</span><br><span class="line">           &#x2F;&#x2F;【见小节2.1】</span><br><span class="line">           forceStopPackage(packageName, userId);</span><br><span class="line">           reply.writeNoException();</span><br><span class="line">           return true;</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AMP.forceStopPackage来运行在执行adb时所创建的进程，经过Binder Driver后，进入system_server进程的一个binder线程来执行AMN.forceStopPackage，从这开始的操作(包括当前操作)便都运行在system_server系统进程。</p>
<h3 id="1-8-小节"><a href="#1-8-小节" class="headerlink" title="1.8 小节"></a>1.8 小节</h3><p><img src="http://gityuan.com/images/process/am_force_stop.jpg" alt="am_force_stop"></p>
<p>进程绝杀技force-stop，并非任意app可直接调用, 否则App间可以相互停止对方，则岂非天下大乱。该方法的存在便是供系统差遣。一般地，点击home弹出的清理用户最近使用app采取的策略便是force-stop.</p>
<p>至于force-stop的触发方式，除了adb的方式，还可通过获取ActivityManager再调用其方法forceStopPackage()，不过这是@hide隐藏方法，同样是需要具有FORCE_STOP_PACKAGES权限。虽然第三方普通app不能直接调用，但对于深入理解Android，还是很有必要知道系统是如何彻底清理进程的过程。接下来，进入AMS来深入探查force-stop的内部机理。</p>
<h2 id="二-force-stop内部机理"><a href="#二-force-stop内部机理" class="headerlink" title="二. force-stop内部机理"></a>二. force-stop内部机理</h2><h3 id="2-1-AMS-forceStopPackage"><a href="#2-1-AMS-forceStopPackage" class="headerlink" title="2.1 AMS.forceStopPackage"></a>2.1 AMS.forceStopPackage</h3><p>[-&gt; ActivityManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void forceStopPackage(final String packageName, int userId) &#123;</span><br><span class="line">    if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES)</span><br><span class="line">                    !&#x3D; PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        &#x2F;&#x2F;需要权限permission.FORCE_STOP_PACKAGES</span><br><span class="line">        throw new SecurityException();</span><br><span class="line">    &#125;</span><br><span class="line">    final int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">    userId &#x3D; handleIncomingUser(callingPid, Binder.getCallingUid(),</span><br><span class="line">                    userId, true, ALLOW_FULL_ONLY, &quot;forceStopPackage&quot;, null);</span><br><span class="line">    long callingId &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">    try &#123;</span><br><span class="line">        IPackageManager pm &#x3D; AppGlobals.getPackageManager();</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            int[] users &#x3D; userId &#x3D;&#x3D; UserHandle.USER_ALL</span><br><span class="line">                            ? getUsersLocked() : new int[] &#123; userId &#125;;</span><br><span class="line">            for (int user : users) &#123;</span><br><span class="line">                    int pkgUid &#x3D; -1;</span><br><span class="line">                    &#x2F;&#x2F;根据包名和userId来查询相应的uid</span><br><span class="line">                    pkgUid &#x3D; pm.getPackageUid(packageName, user);</span><br><span class="line">                    &#x2F;&#x2F;设置包的状态为stopped</span><br><span class="line">                    pm.setPackageStoppedState(packageName, true, user);</span><br><span class="line"></span><br><span class="line">                    if (isUserRunningLocked(user, false)) &#123;</span><br><span class="line">                            &#x2F;&#x2F;【见流程2.2】</span><br><span class="line">                            forceStopPackageLocked(packageName, pkgUid, &quot;from pid &quot; + callingPid);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(callingId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个过程非常重要，那就是setPackageStoppedState()将包的状态设置为stopped，那么所有广播都无法接收，除非带有标记<code>FLAG_INCLUDE_STOPPED_PACKAGES</code>的广播，系统默认的广播几乎都是不带有该标志，也就意味着被force-stop的应用是无法通过建立手机网络状态或者亮灭的广播来拉起进程。</p>
<p>当使用force stop方式来结束进程时, reason一般都是”from pid “ + callingPid. 当然也有另外,那就是AMS.clearApplicationUserData方法调用forceStopPackageLocked的reason为”clear data”.</p>
<h3 id="2-2-AMS-forceStopPackageLocked"><a href="#2-2-AMS-forceStopPackageLocked" class="headerlink" title="2.2 AMS.forceStopPackageLocked"></a>2.2 AMS.forceStopPackageLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void forceStopPackageLocked(final String packageName, int uid, String reason) &#123;</span><br><span class="line">    &#x2F;&#x2F;[见流程2.3]</span><br><span class="line">    forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false,</span><br><span class="line">                false, true, false, false, UserHandle.getUserId(uid), reason);</span><br><span class="line"></span><br><span class="line">    Intent intent &#x3D; new Intent(Intent.ACTION_PACKAGE_RESTARTED,</span><br><span class="line">                Uri.fromParts(&quot;package&quot;, packageName, null));</span><br><span class="line">    &#x2F;&#x2F;系统启动完毕后,则mProcessesReady&#x3D;true</span><br><span class="line">    if (!mProcessesReady) &#123;</span><br><span class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                        | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">    &#125;</span><br><span class="line">    intent.putExtra(Intent.EXTRA_UID, uid);</span><br><span class="line">    intent.putExtra(Intent.EXTRA_USER_HANDLE, UserHandle.getUserId(uid));</span><br><span class="line">    &#x2F;&#x2F;发送广播用于停止alarm以及通知 【见小节8.1】</span><br><span class="line">    broadcastIntentLocked(null, null, intent,</span><br><span class="line">                    null, null, 0, null, null, null, AppOpsManager.OP_NONE,</span><br><span class="line">                    null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.getUserId(uid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清理跟该包名相关的进程和四大组件之外，还会发送广播ACTION_PACKAGE_RESTARTED，用于清理已注册的alarm,notification信息。</p>
<h3 id="2-3-AMS-forceStopPackageLocked"><a href="#2-3-AMS-forceStopPackageLocked" class="headerlink" title="2.3 AMS.forceStopPackageLocked"></a>2.3 AMS.forceStopPackageLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;callerWillRestart &#x3D; false, doit &#x3D; true;</span><br><span class="line">private final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) &#123;</span><br><span class="line">     int i;</span><br><span class="line"></span><br><span class="line">     if (appId &lt; 0 &amp;&amp; packageName !&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 重新获取正确的appId</span><br><span class="line">         appId &#x3D; UserHandle.getAppId(</span><br><span class="line">                 AppGlobals.getPackageManager().getPackageUid(packageName, 0));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; doit &#x3D;true能进入该分支</span><br><span class="line">     if (doit) &#123;</span><br><span class="line">         final ArrayMap&lt;String, SparseArray&lt;Long&gt;&gt; pmap &#x3D; mProcessCrashTimes.getMap();</span><br><span class="line">         for (int ip &#x3D; pmap.size() - 1; ip &gt;&#x3D; 0; ip--) &#123;</span><br><span class="line">             SparseArray&lt;Long&gt; ba &#x3D; pmap.valueAt(ip);</span><br><span class="line">             for (i &#x3D; ba.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                 boolean remove &#x3D; false;</span><br><span class="line">                 final int entUid &#x3D; ba.keyAt(i);</span><br><span class="line">                 if (packageName !&#x3D; null) &#123;</span><br><span class="line">                     if (userId &#x3D;&#x3D; UserHandle.USER_ALL) &#123;</span><br><span class="line">                         if (UserHandle.getAppId(entUid) &#x3D;&#x3D; appId) &#123;</span><br><span class="line">                             remove &#x3D; true;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125; else &#123;</span><br><span class="line">                         if (entUid &#x3D;&#x3D; UserHandle.getUid(userId, appId)) &#123;</span><br><span class="line">                             remove &#x3D; true;</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125; else if (UserHandle.getUserId(entUid) &#x3D;&#x3D; userId) &#123;</span><br><span class="line">                     remove &#x3D; true;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (remove) &#123;</span><br><span class="line">                     ba.removeAt(i);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             if (ba.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                 pmap.removeAt(ip);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;清理Process [见流程3.1]</span><br><span class="line">     boolean didSomething &#x3D; killPackageProcessesLocked(packageName, appId, userId,</span><br><span class="line">             -100, callerWillRestart, true, doit, evenPersistent,</span><br><span class="line">             packageName &#x3D;&#x3D; null ? (&quot;stop user &quot; + userId) : (&quot;stop &quot; + packageName));</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;清理Activity [见流程4.1]</span><br><span class="line">     if (mStackSupervisor.finishDisabledPackageActivitiesLocked(</span><br><span class="line">             packageName, null, doit, evenPersistent, userId)) &#123;</span><br><span class="line">         ...</span><br><span class="line">         didSomething &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 结束该包中的Service [见流程5.1]</span><br><span class="line">     if (mServices.bringDownDisabledPackageServicesLocked(</span><br><span class="line">             packageName, null, userId, evenPersistent, true, doit)) &#123;</span><br><span class="line">         ...</span><br><span class="line">         didSomething &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (packageName &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F;当包名为空, 则移除当前用户的所有sticky broadcasts</span><br><span class="line">         mStickyBroadcasts.remove(userId);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;收集providers [见流程6.1]</span><br><span class="line">     ArrayList&lt;ContentProviderRecord&gt; providers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">     if (mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent,</span><br><span class="line">             userId, providers)) &#123;</span><br><span class="line">          ...</span><br><span class="line">         didSomething &#x3D; true;</span><br><span class="line">     &#125;</span><br><span class="line">     for (i &#x3D; providers.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">          &#x2F;&#x2F;清理providers [见流程6.3]</span><br><span class="line">         removeDyingProviderLocked(null, providers.get(i), true);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;移除已获取的跟该package&#x2F;user相关的临时权限</span><br><span class="line">     removeUriPermissionsForPackageLocked(packageName, userId, false);</span><br><span class="line"></span><br><span class="line">     if (doit) &#123;</span><br><span class="line">         &#x2F;&#x2F; 清理Broadcast [见流程7.1]</span><br><span class="line">         for (i &#x3D; mBroadcastQueues.length - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">             didSomething |&#x3D; mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(</span><br><span class="line">                     packageName, null, userId, doit);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (packageName &#x3D;&#x3D; null || uninstalling) &#123;</span><br><span class="line">         ... &#x2F;&#x2F;包名为空的情况</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (doit) &#123;</span><br><span class="line">         if (purgeCache &amp;&amp; packageName !&#x3D; null) &#123;</span><br><span class="line">            ... &#x2F;&#x2F;不进入该分支</span><br><span class="line">         &#125;</span><br><span class="line">         if (mBooted) &#123;</span><br><span class="line">             &#x2F;&#x2F;恢复栈顶的activity</span><br><span class="line">             mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">             mStackSupervisor.scheduleIdleLocked();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return didSomething;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>didSomething</code>只指当方法中所有行为,则返回true.比如killPackageProcessesLocked(),只要杀过一个进程则代表didSomething为true.</p>
<p>该方法的主要功能:</p>
<ol>
<li>Process: 调用AMS.killPackageProcessesLocked()清理该package所涉及的进程;</li>
<li>Activity: 调用ASS.finishDisabledPackageActivitiesLocked()清理该package所涉及的Activity;</li>
<li>Service: 调用AS.bringDownDisabledPackageServicesLocked()清理该package所涉及的Service;</li>
<li>Provider: 调用AMS.removeDyingProviderLocked()清理该package所涉及的Provider;</li>
<li>BroadcastRecevier: 调用BQ.cleanupDisabledPackageReceiversLocked()清理该package所涉及的广播</li>
</ol>
<p>接下来,从这5个角度来分别说说force-stop的执行过程.</p>
<h2 id="三-Process"><a href="#三-Process" class="headerlink" title="三. Process"></a>三. Process</h2><h3 id="3-1-AMS-killPackageProcessesLocked"><a href="#3-1-AMS-killPackageProcessesLocked" class="headerlink" title="3.1 AMS.killPackageProcessesLocked"></a>3.1 AMS.killPackageProcessesLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;callerWillRestart &#x3D; false, allowRestart &#x3D; true, doit &#x3D; true;</span><br><span class="line">private final boolean killPackageProcessesLocked(String packageName, int appId, int userId, int minOomAdj, boolean callerWillRestart, boolean allowRestart, boolean doit, boolean evenPersistent, String reason) &#123;</span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procs &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;遍历当前所有运行中的进程</span><br><span class="line">    final int NP &#x3D; mProcessNames.getMap().size();</span><br><span class="line">    for (int ip&#x3D;0; ip&lt;NP; ip++) &#123;</span><br><span class="line">        SparseArray&lt;ProcessRecord&gt; apps &#x3D; mProcessNames.getMap().valueAt(ip);</span><br><span class="line">        final int NA &#x3D; apps.size();</span><br><span class="line">        for (int ia&#x3D;0; ia&lt;NA; ia++) &#123;</span><br><span class="line">            ProcessRecord app &#x3D; apps.valueAt(ia);</span><br><span class="line">            if (app.persistent &amp;&amp; !evenPersistent) &#123;</span><br><span class="line">                continue; &#x2F;&#x2F;不杀persistent进程</span><br><span class="line">            &#125;</span><br><span class="line">            if (app.removed) &#123;</span><br><span class="line">                &#x2F;&#x2F;已标记removed的进程，便是需要被杀的进程，加入procs队列</span><br><span class="line">                if (doit) &#123;</span><br><span class="line">                    procs.add(app);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (app.setAdj &lt; minOomAdj) &#123;</span><br><span class="line">                continue; &#x2F;&#x2F;不杀adj低于预期的进程</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (packageName &#x3D;&#x3D; null) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#x2F;&#x2F;已指定包名的情况</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;pkgDeps: 该进程所依赖的包名</span><br><span class="line">                final boolean isDep &#x3D; app.pkgDeps !&#x3D; null</span><br><span class="line">                        &amp;&amp; app.pkgDeps.contains(packageName);</span><br><span class="line">                if (!isDep &amp;&amp; UserHandle.getAppId(app.uid) !&#x3D; appId) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (userId !&#x3D; UserHandle.USER_ALL &amp;&amp; app.userId !&#x3D; userId) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;pkgList: 运行在该进程的所有包名;</span><br><span class="line">                if (!app.pkgList.containsKey(packageName) &amp;&amp; !isDep) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;通过前面所有条件,则意味着该进程需要被杀, 添加到procs队列</span><br><span class="line">            app.removed &#x3D; true;</span><br><span class="line">            procs.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int N &#x3D; procs.size();</span><br><span class="line">    for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; [见流程3.2]</span><br><span class="line">        removeProcessLocked(procs.get(i), callerWillRestart, allowRestart, reason);</span><br><span class="line">    &#125;</span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">    return N &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般地force-stop会指定包名，该方法会遍历当前所有运行中的进程<code>mProcessNames</code>，以下条件同时都不满足的进程，则会成为被杀的目标进程：(也就是说满足以下任一条件都可以免死)</p>
<ol>
<li>persistent进程：</li>
<li>进程setAdj &lt; minOomAdj(默认为-100)：</li>
<li>非UserHandle.USER_ALL同时, 且进程的userId不相等：多用户模型下，不同用户下不能相互杀；</li>
<li>进程没有依赖该packageName, 且进程的AppId不相等;</li>
<li>进程没有依赖该packageName, 且该packageName没有运行在该进程.</li>
</ol>
<p>通俗地来说就是：</p>
<ul>
<li>forceStop不杀系统persistent进程；</li>
<li>当指定用户userId时，不杀其他用户空间的进程；</li>
</ul>
<p>除此之外，以下情况则必然会成为被杀进程：</p>
<ul>
<li>进程已标记<code>remove</code>=true的进程，则会被杀；</li>
<li>进程的<code>pkgDeps</code>中包含该<code>packageName</code>，则会被杀；</li>
<li>进程的<code>pkgList</code>中包含该<code>packageName</code>，且该进程与包名所指定的AppId相等则会被杀；</li>
</ul>
<p>进程的<code>pkgList</code>是在启动组件或者创建进程的过程向该队列添加的，代表的是该应用下有组件运行在该进程。那么<code>pkgDeps</code>是指该进程所依赖的包名，调用ClassLoader的过程添加。</p>
<h3 id="3-2-AMS-removeProcessLocked"><a href="#3-2-AMS-removeProcessLocked" class="headerlink" title="3.2 AMS.removeProcessLocked"></a>3.2 AMS.removeProcessLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;callerWillRestart &#x3D; false, allowRestart &#x3D; true</span><br><span class="line">private final boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) &#123;</span><br><span class="line">     final String name &#x3D; app.processName;</span><br><span class="line">     final int uid &#x3D; app.uid;</span><br><span class="line">     &#x2F;&#x2F;从mProcessNames移除该进程</span><br><span class="line">     removeProcessNameLocked(name, uid);</span><br><span class="line">     if (mHeavyWeightProcess &#x3D;&#x3D; app) &#123;</span><br><span class="line">        ...</span><br><span class="line">     &#125;</span><br><span class="line">     boolean needRestart &#x3D; false;</span><br><span class="line">     if (app.pid &gt; 0 &amp;&amp; app.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">         int pid &#x3D; app.pid;</span><br><span class="line">         synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">             mPidsSelfLocked.remove(pid);</span><br><span class="line">             mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (app.isolated) &#123;</span><br><span class="line">             mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);</span><br><span class="line">         &#125;</span><br><span class="line">         boolean willRestart &#x3D; false;</span><br><span class="line">         if (app.persistent &amp;&amp; !app.isolated) &#123;</span><br><span class="line">             if (!callerWillRestart) &#123;</span><br><span class="line">                 willRestart &#x3D; true; &#x2F;&#x2F;用于标记persistent进程则需重启进程</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 needRestart &#x3D; true; &#x2F;&#x2F;用于返回值，作用不大</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F;杀掉该进程</span><br><span class="line">         app.kill(reason, true);</span><br><span class="line">         &#x2F;&#x2F;清理该进程相关的信息</span><br><span class="line">         handleAppDiedLocked(app, willRestart, allowRestart);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F;对于persistent进程,则需要重新启动该进程</span><br><span class="line">         if (willRestart) &#123;</span><br><span class="line">             removeLruProcessLocked(app);</span><br><span class="line">             addAppLocked(app.info, false, null &#x2F;* ABI override *&#x2F;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         mRemovedProcesses.add(app);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     return needRestart;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>该方法的主要功能:</p>
<ul>
<li>从mProcessNames, mPidsSelfLocked队列移除该进程;</li>
<li>移除进程启动超时的消息PROC_START_TIMEOUT_MSG;</li>
<li>调用app.kill()来杀进程会同时调用Process.kill和Process.killProcessGroup, 该过程详见<a href="http://gityuan.com/2016/04/16/kill-signal/" target="_blank" rel="noopener">理解杀进程的实现原理</a></li>
<li>调用handleAppDiedLocked()来清理进程相关的信息, 该过程详见<a href="http://gityuan.com/2016/10/02/binder-died/" target="_blank" rel="noopener">binderDied()过程分析</a></li>
</ul>
<h2 id="四-Activity"><a href="#四-Activity" class="headerlink" title="四. Activity"></a>四. Activity</h2><h3 id="4-1-ASS-finishDisabledPackageActivitiesLocked"><a href="#4-1-ASS-finishDisabledPackageActivitiesLocked" class="headerlink" title="4.1 ASS.finishDisabledPackageActivitiesLocked"></a>4.1 ASS.finishDisabledPackageActivitiesLocked</h3><p>[-&gt; ActivityStackSupervisor.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean finishDisabledPackageActivitiesLocked(String packageName, Set&lt;String&gt; filterByClasses, boolean doit, boolean evenPersistent, int userId) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    for (int displayNdx &#x3D; mActivityDisplays.size() - 1; displayNdx &gt;&#x3D; 0; --displayNdx) &#123;</span><br><span class="line">        final ArrayList&lt;ActivityStack&gt; stacks &#x3D; mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        final int numStacks &#x3D; stacks.size();</span><br><span class="line">        for (int stackNdx &#x3D; 0; stackNdx &lt; numStacks; ++stackNdx) &#123;</span><br><span class="line">            final ActivityStack stack &#x3D; stacks.get(stackNdx);</span><br><span class="line">            &#x2F;&#x2F; [见流程4.2]</span><br><span class="line">            if (stack.finishDisabledPackageActivitiesLocked(</span><br><span class="line">                    packageName, filterByClasses, doit, evenPersistent, userId)) &#123;</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-AS-finishDisabledPackageActivitiesLocked"><a href="#4-2-AS-finishDisabledPackageActivitiesLocked" class="headerlink" title="4.2 AS.finishDisabledPackageActivitiesLocked"></a>4.2 AS.finishDisabledPackageActivitiesLocked</h3><p>[-&gt; ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; doit &#x3D; true;</span><br><span class="line">boolean finishDisabledPackageActivitiesLocked(String packageName, Set&lt;String&gt; filterByClasses, boolean doit, boolean evenPersistent, int userId) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    TaskRecord lastTask &#x3D; null;</span><br><span class="line">    ComponentName homeActivity &#x3D; null;</span><br><span class="line"></span><br><span class="line">    for (int taskNdx &#x3D; mTaskHistory.size() - 1; taskNdx &gt;&#x3D; 0; --taskNdx) &#123;</span><br><span class="line">        final ArrayList&lt;ActivityRecord&gt; activities &#x3D; mTaskHistory.get(taskNdx).mActivities;</span><br><span class="line">        int numActivities &#x3D; activities.size();</span><br><span class="line">        for (int activityNdx &#x3D; 0; activityNdx &lt; numActivities; ++activityNdx) &#123;</span><br><span class="line">            ActivityRecord r &#x3D; activities.get(activityNdx);</span><br><span class="line">            final boolean sameComponent &#x3D;</span><br><span class="line">                    (r.packageName.equals(packageName) &amp;&amp; (filterByClasses &#x3D;&#x3D; null</span><br><span class="line">                            || filterByClasses.contains(r.realActivity.getClassName())))</span><br><span class="line">                    || (packageName &#x3D;&#x3D; null &amp;&amp; r.userId &#x3D;&#x3D; userId);</span><br><span class="line">            if ((userId &#x3D;&#x3D; UserHandle.USER_ALL || r.userId &#x3D;&#x3D; userId)</span><br><span class="line">                    &amp;&amp; (sameComponent || r.task &#x3D;&#x3D; lastTask)</span><br><span class="line">                    &amp;&amp; (r.app &#x3D;&#x3D; null || evenPersistent || !r.app.persistent)) &#123;</span><br><span class="line">                ...</span><br><span class="line">                if (r.isHomeActivity()) &#123;</span><br><span class="line">                    if (homeActivity !&#x3D; null &amp;&amp; homeActivity.equals(r.realActivity)) &#123;</span><br><span class="line">                        continue; &#x2F;&#x2F;不结束home activity</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        homeActivity &#x3D; r.realActivity;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (sameComponent) &#123;</span><br><span class="line">                    if (r.app !&#x3D; null) &#123;</span><br><span class="line">                        r.app.removed &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    r.app &#x3D; null;</span><br><span class="line">                &#125;</span><br><span class="line">                lastTask &#x3D; r.task;</span><br><span class="line">                &#x2F;&#x2F;强制结束该Activity [见流程4.3]</span><br><span class="line">                if (finishActivityLocked(r, Activity.RESULT_CANCELED, null, &quot;force-stop&quot;,</span><br><span class="line">                        true)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; r已从mActivities中移除</span><br><span class="line">                    --numActivities;</span><br><span class="line">                    --activityNdx;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-AS-finishActivityLocked"><a href="#4-3-AS-finishActivityLocked" class="headerlink" title="4.3 AS.finishActivityLocked"></a>4.3 AS.finishActivityLocked</h3><p>[-&gt; ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) &#123;</span><br><span class="line">    if (r.finishing) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;[见流程4.3.1]</span><br><span class="line">    r.makeFinishingLocked();</span><br><span class="line">    final TaskRecord task &#x3D; r.task;</span><br><span class="line"></span><br><span class="line">    final ArrayList&lt;ActivityRecord&gt; activities &#x3D; task.mActivities;</span><br><span class="line">    final int index &#x3D; activities.indexOf(r);</span><br><span class="line">    if (index &lt; (activities.size() - 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F;[见流程4.3.3]</span><br><span class="line">        task.setFrontOfTask();</span><br><span class="line">        if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET) !&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F;当该activity会被移除,则将该activity信息传播给下一个activity</span><br><span class="line">            ActivityRecord next &#x3D; activities.get(index+1);</span><br><span class="line">            next.intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;暂停按键事件的分发</span><br><span class="line">    r.pauseKeyDispatchingLocked();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调整聚焦的activity [见流程4.3.4]</span><br><span class="line">    adjustFocusedActivityLocked(r, &quot;finishActivity&quot;);</span><br><span class="line">    &#x2F;&#x2F;重置activity的回调结果信息</span><br><span class="line">    finishActivityResultsLocked(r, resultCode, resultData);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当r为前台可见的activity时</span><br><span class="line">    if (mResumedActivity &#x3D;&#x3D; r) &#123;</span><br><span class="line">        boolean endTask &#x3D; index &lt;&#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;准备关闭该transition</span><br><span class="line">        mWindowManager.prepareAppTransition(endTask</span><br><span class="line">                ? AppTransition.TRANSIT_TASK_CLOSE</span><br><span class="line">                : AppTransition.TRANSIT_ACTIVITY_CLOSE, false);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;告知wms来准备从窗口移除该activity</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, false);</span><br><span class="line"></span><br><span class="line">        if (mPausingActivity &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;暂停该activity</span><br><span class="line">            startPausingLocked(false, false, false, false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (endTask) &#123;</span><br><span class="line">            mStackSupervisor.removeLockedTaskLocked(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (r.state !&#x3D; ActivityState.PAUSING) &#123;</span><br><span class="line">        &#x2F;&#x2F;当r不可见的情况 [见流程4.3.5]</span><br><span class="line">        return finishCurrentActivityLocked(r, FINISH_AFTER_PAUSE, oomAdj) &#x3D;&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-1-AR-makeFinishingLocked"><a href="#4-3-1-AR-makeFinishingLocked" class="headerlink" title="4.3.1 AR.makeFinishingLocked"></a>4.3.1 AR.makeFinishingLocked</h4><p>[-&gt; ActivityRecord.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void makeFinishingLocked() &#123;</span><br><span class="line">    if (!finishing) &#123;</span><br><span class="line">        if (task !&#x3D; null &amp;&amp; task.stack !&#x3D; null</span><br><span class="line">                &amp;&amp; this &#x3D;&#x3D; task.stack.getVisibleBehindActivity()) &#123;</span><br><span class="line">            &#x2F;&#x2F;处于finishing的activity不应该在后台保留可见性 [见流程4.3.2]</span><br><span class="line">            mStackSupervisor.requestVisibleBehindLocked(this, false);</span><br><span class="line">        &#125;</span><br><span class="line">        finishing &#x3D; true;</span><br><span class="line">        if (stopped) &#123;</span><br><span class="line">            clearOptionsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-ASS-requestVisibleBehindLocked"><a href="#4-3-2-ASS-requestVisibleBehindLocked" class="headerlink" title="4.3.2 ASS.requestVisibleBehindLocked"></a>4.3.2 ASS.requestVisibleBehindLocked</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean requestVisibleBehindLocked(ActivityRecord r, boolean visible) &#123;</span><br><span class="line">    final ActivityStack stack &#x3D; r.task.stack;</span><br><span class="line">    if (stack &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false; &#x2F;&#x2F;r所在栈为空,则直接返回</span><br><span class="line">    &#125;</span><br><span class="line">    final boolean isVisible &#x3D; stack.hasVisibleBehindActivity();</span><br><span class="line"></span><br><span class="line">    final ActivityRecord top &#x3D; topRunningActivityLocked();</span><br><span class="line">    if (top &#x3D;&#x3D; null || top &#x3D;&#x3D; r || (visible &#x3D;&#x3D; isVisible)) &#123;</span><br><span class="line">        stack.setVisibleBehindActivity(visible ? r : null);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (visible &amp;&amp; top.fullscreen) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; else if (!visible &amp;&amp; stack.getVisibleBehindActivity() !&#x3D; r) &#123;</span><br><span class="line">        &#x2F;&#x2F;设置不可见,且当前top activity跟该activity相同时返回</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.setVisibleBehindActivity(visible ? r : null);</span><br><span class="line">    if (!visible) &#123;</span><br><span class="line">        &#x2F;&#x2F;将activity置于不透明的r之上</span><br><span class="line">        final ActivityRecord next &#x3D; stack.findNextTranslucentActivity(r);</span><br><span class="line">        if (next !&#x3D; null) &#123;</span><br><span class="line">            mService.convertFromTranslucent(next.appToken);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (top.app !&#x3D; null &amp;&amp; top.app.thread !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;将改变通知给top应用</span><br><span class="line">        top.app.thread.scheduleBackgroundVisibleBehindChanged(top.appToken, visible);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-TaskRecord-setFrontOfTask"><a href="#4-3-3-TaskRecord-setFrontOfTask" class="headerlink" title="4.3.3 TaskRecord.setFrontOfTask"></a>4.3.3 TaskRecord.setFrontOfTask</h4><p>[-&gt; TaskRecord.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final void setFrontOfTask() &#123;</span><br><span class="line">    boolean foundFront &#x3D; false;</span><br><span class="line">    final int numActivities &#x3D; mActivities.size();</span><br><span class="line">    for (int activityNdx &#x3D; 0; activityNdx &lt; numActivities; ++activityNdx) &#123;</span><br><span class="line">        final ActivityRecord r &#x3D; mActivities.get(activityNdx);</span><br><span class="line">        if (foundFront || r.finishing) &#123;</span><br><span class="line">            r.frontOfTask &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r.frontOfTask &#x3D; true;</span><br><span class="line">            foundFront &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;所有activity都处于finishing状态.</span><br><span class="line">    if (!foundFront &amp;&amp; numActivities &gt; 0) &#123;</span><br><span class="line">        mActivities.get(0).frontOfTask &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将该Task中从底部往上查询, 第一个处于非finishing状态的ActivityRecord,则设置为根Activity(即r.frontOfTask = true),其他都为false;</li>
<li>当所有的activity都处于finishing状态,则把最底部的activity设置成跟Activity.</li>
</ul>
<h4 id="4-3-4-AS-adjustFocusedActivityLocked"><a href="#4-3-4-AS-adjustFocusedActivityLocked" class="headerlink" title="4.3.4 AS.adjustFocusedActivityLocked"></a>4.3.4 AS.adjustFocusedActivityLocked</h4><p>[-&gt; ActivityStack.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void adjustFocusedActivityLocked(ActivityRecord r, String reason) &#123;</span><br><span class="line">    if (mStackSupervisor.isFrontStack(this) &amp;&amp; mService.mFocusedActivity &#x3D;&#x3D; r) &#123;</span><br><span class="line">        ActivityRecord next &#x3D; topRunningActivityLocked(null);</span><br><span class="line">        final String myReason &#x3D; reason + &quot; adjustFocus&quot;;</span><br><span class="line">        if (next !&#x3D; r) &#123;</span><br><span class="line">            final TaskRecord task &#x3D; r.task;</span><br><span class="line">            boolean adjust &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F;当下一个activity为空, 或者下一个与当前的task不同, 或者要结束的r为根activity.</span><br><span class="line">            if ((next &#x3D;&#x3D; null || next.task !&#x3D; task) &amp;&amp; r.frontOfTask) &#123;</span><br><span class="line">                if (task.isOverHomeStack() &amp;&amp; task &#x3D;&#x3D; topTask()) &#123;</span><br><span class="line">                    adjust &#x3D; true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    for (int taskNdx &#x3D; mTaskHistory.size() - 1; taskNdx &gt;&#x3D; 0; --taskNdx) &#123;</span><br><span class="line">                        final TaskRecord tr &#x3D; mTaskHistory.get(taskNdx);</span><br><span class="line">                        if (tr.getTopActivity() !&#x3D; null) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125; else if (tr.isOverHomeStack()) &#123;</span><br><span class="line">                            adjust &#x3D; true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 需要调整Activity的聚焦情况</span><br><span class="line">            if (adjust) &#123;</span><br><span class="line">                &#x2F;&#x2F; 对于非全屏的stack, 则移动角度到下一个可见的栈,而不是直接移动到home栈而屏蔽其他可见的栈.</span><br><span class="line">                if (!mFullscreen</span><br><span class="line">                        &amp;&amp; adjustFocusToNextVisibleStackLocked(null, myReason)) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当该栈为全屏,或者没有其他可见栈时, 则把home栈移至顶部</span><br><span class="line">                if (mStackSupervisor.moveHomeStackTaskToTop(</span><br><span class="line">                        task.getTaskToReturnTo(), myReason)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;聚焦已调整完整,则直接返回</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ActivityRecord top &#x3D; mStackSupervisor.topRunningActivityLocked();</span><br><span class="line">        if (top !&#x3D; null) &#123;</span><br><span class="line">            mService.setFocusedActivityLocked(top, myReason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-AS-finishCurrentActivityLocked"><a href="#4-3-5-AS-finishCurrentActivityLocked" class="headerlink" title="4.3.5 AS.finishCurrentActivityLocked"></a>4.3.5 AS.finishCurrentActivityLocked</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final ActivityRecord finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) &#123;</span><br><span class="line">    if (mode &#x3D;&#x3D; FINISH_AFTER_VISIBLE &amp;&amp; r.nowVisible) &#123;</span><br><span class="line">        if (!mStackSupervisor.mStoppingActivities.contains(r)) &#123;</span><br><span class="line">            mStackSupervisor.mStoppingActivities.add(r);</span><br><span class="line">            if (mStackSupervisor.mStoppingActivities.size() &gt; 3</span><br><span class="line">                    || r.frontOfTask &amp;&amp; mTaskHistory.size() &lt;&#x3D; 1) &#123;</span><br><span class="line">                mStackSupervisor.scheduleIdleLocked();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;设置状态为stopping</span><br><span class="line">        r.state &#x3D; ActivityState.STOPPING;</span><br><span class="line">        if (oomAdj) &#123;</span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;清除相关信息</span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(r);</span><br><span class="line">    mStackSupervisor.mGoingToSleepActivities.remove(r);</span><br><span class="line">    mStackSupervisor.mWaitingVisibleActivities.remove(r);</span><br><span class="line">    if (mResumedActivity &#x3D;&#x3D; r) &#123;</span><br><span class="line">        mResumedActivity &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    final ActivityState prevState &#x3D; r.state;</span><br><span class="line">    &#x2F;&#x2F;设置状态为finishing</span><br><span class="line">    r.state &#x3D; ActivityState.FINISHING;</span><br><span class="line"></span><br><span class="line">    if (mode &#x3D;&#x3D; FINISH_IMMEDIATELY</span><br><span class="line">            || (mode &#x3D;&#x3D; FINISH_AFTER_PAUSE &amp;&amp; prevState &#x3D;&#x3D; ActivityState.PAUSED)</span><br><span class="line">            || prevState &#x3D;&#x3D; ActivityState.STOPPED</span><br><span class="line">            || prevState &#x3D;&#x3D; ActivityState.INITIALIZING) &#123;</span><br><span class="line">        r.makeFinishingLocked();</span><br><span class="line">        &#x2F;&#x2F;[见流程4.3.6]</span><br><span class="line">        boolean activityRemoved &#x3D; destroyActivityLocked(r, true, &quot;finish-imm&quot;);</span><br><span class="line">        if (activityRemoved) &#123;</span><br><span class="line">            mStackSupervisor.resumeTopActivitiesLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        return activityRemoved ? null : r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;需要等到activity执行完pause,进入stopped状态,才会finish</span><br><span class="line">    mStackSupervisor.mFinishingActivities.add(r);</span><br><span class="line">    r.resumeKeyDispatchingLocked();</span><br><span class="line">    mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null);</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满足下面其中之一的条件,则会执行finish以及destroy Activity.</p>
<ol>
<li>模式为FINISH_IMMEDIATELY</li>
<li>模式为FINISH_AFTER_PAUSE, 且Activity状态已处于PAUSED;</li>
<li>Activity的状态为STOPPED或INITIALIZING.</li>
</ol>
<h4 id="4-3-6-AS-destroyActivityLocked"><a href="#4-3-6-AS-destroyActivityLocked" class="headerlink" title="4.3.6 AS.destroyActivityLocked"></a>4.3.6 AS.destroyActivityLocked</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) &#123;</span><br><span class="line"></span><br><span class="line">     boolean removedFromHistory &#x3D; false;</span><br><span class="line"></span><br><span class="line">     cleanUpActivityLocked(r, false, false);</span><br><span class="line">     final boolean hadApp &#x3D; r.app !&#x3D; null;</span><br><span class="line"></span><br><span class="line">     if (hadApp) &#123;</span><br><span class="line">         if (removeFromApp) &#123;</span><br><span class="line">             r.app.activities.remove(r);</span><br><span class="line">             if (mService.mHeavyWeightProcess &#x3D;&#x3D; r.app &amp;&amp; r.app.activities.size() &lt;&#x3D; 0) &#123;</span><br><span class="line">                 mService.mHeavyWeightProcess &#x3D; null;</span><br><span class="line">                 mService.mHandler.sendEmptyMessage(ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">             &#125;</span><br><span class="line">             if (r.app.activities.isEmpty()) &#123;</span><br><span class="line">                 mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">                 mService.updateLruProcessLocked(r.app, false, null);</span><br><span class="line">                 mService.updateOomAdjLocked();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         boolean skipDestroy &#x3D; false;</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing,</span><br><span class="line">                     r.configChangeFlags);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">             if (r.finishing) &#123;</span><br><span class="line">                 &#x2F;&#x2F;当发生crash,则将该activity从history移除</span><br><span class="line">                 removeActivityFromHistoryLocked(r, reason + &quot; exceptionInScheduleDestroy&quot;);</span><br><span class="line">                 removedFromHistory &#x3D; true;</span><br><span class="line">                 skipDestroy &#x3D; true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         r.nowVisible &#x3D; false;</span><br><span class="line"></span><br><span class="line">         if (r.finishing &amp;&amp; !skipDestroy) &#123;</span><br><span class="line">             r.state &#x3D; ActivityState.DESTROYING;</span><br><span class="line">             Message msg &#x3D; mHandler.obtainMessage(DESTROY_TIMEOUT_MSG, r);</span><br><span class="line">             mHandler.sendMessageDelayed(msg, DESTROY_TIMEOUT);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             r.state &#x3D; ActivityState.DESTROYED;</span><br><span class="line">             r.app &#x3D; null;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (r.finishing) &#123;</span><br><span class="line">             removeActivityFromHistoryLocked(r, reason + &quot; hadNoApp&quot;);</span><br><span class="line">             removedFromHistory &#x3D; true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             r.state &#x3D; ActivityState.DESTROYED;</span><br><span class="line">             r.app &#x3D; null;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     r.configChangeFlags &#x3D; 0;</span><br><span class="line">     return removedFromHistory;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="五-Service"><a href="#五-Service" class="headerlink" title="五. Service"></a>五. Service</h2><h3 id="5-1-bringDownDisabledPackageServicesLocked"><a href="#5-1-bringDownDisabledPackageServicesLocked" class="headerlink" title="5.1 bringDownDisabledPackageServicesLocked"></a>5.1 bringDownDisabledPackageServicesLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;killProcess &#x3D; true; doit &#x3D; true;</span><br><span class="line">boolean bringDownDisabledPackageServicesLocked(String packageName, Set&lt;String&gt; filterByClasses, int userId, boolean evenPersistent, boolean killProcess, boolean doit) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (mTmpCollectionResults !&#x3D; null) &#123;</span><br><span class="line">        mTmpCollectionResults.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userId &#x3D;&#x3D; UserHandle.USER_ALL) &#123;</span><br><span class="line">        for (int i &#x3D; mServiceMap.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            &#x2F;&#x2F;从mServiceMap中查询到所有属于该包下的service [见流程5.2]</span><br><span class="line">            didSomething |&#x3D; collectPackageServicesLocked(packageName, filterByClasses,</span><br><span class="line">                    evenPersistent, doit, killProcess, mServiceMap.valueAt(i).mServicesByName);</span><br><span class="line">            if (!doit &amp;&amp; didSomething) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ServiceMap smap &#x3D; mServiceMap.get(userId);</span><br><span class="line">        if (smap !&#x3D; null) &#123;</span><br><span class="line">            ArrayMap&lt;ComponentName, ServiceRecord&gt; items &#x3D; smap.mServicesByName;</span><br><span class="line">            &#x2F;&#x2F;从mServiceMap中查询到所有属于该包下的service [见流程5.2]</span><br><span class="line">            didSomething &#x3D; collectPackageServicesLocked(packageName, filterByClasses,</span><br><span class="line">                    evenPersistent, doit, killProcess, items);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mTmpCollectionResults !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F;结束掉所有收集到的Service [见流程5.3]</span><br><span class="line">        for (int i &#x3D; mTmpCollectionResults.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            bringDownServiceLocked(mTmpCollectionResults.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        mTmpCollectionResults.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-collectPackageServicesLocked"><a href="#5-2-collectPackageServicesLocked" class="headerlink" title="5.2 collectPackageServicesLocked"></a>5.2 collectPackageServicesLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;killProcess &#x3D; true; doit &#x3D; true;</span><br><span class="line">private boolean collectPackageServicesLocked(String packageName, Set&lt;String&gt; filterByClasses, boolean evenPersistent, boolean doit, boolean killProcess, ArrayMap&lt;ComponentName, ServiceRecord&gt; services) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    for (int i &#x3D; services.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        ServiceRecord service &#x3D; services.valueAt(i);</span><br><span class="line">        final boolean sameComponent &#x3D; packageName &#x3D;&#x3D; null</span><br><span class="line">                || (service.packageName.equals(packageName)</span><br><span class="line">                    &amp;&amp; (filterByClasses &#x3D;&#x3D; null</span><br><span class="line">                        || filterByClasses.contains(service.name.getClassName())));</span><br><span class="line">        if (sameComponent</span><br><span class="line">                &amp;&amp; (service.app &#x3D;&#x3D; null || evenPersistent || !service.app.persistent)) &#123;</span><br><span class="line">            if (!doit) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            didSomething &#x3D; true;</span><br><span class="line"></span><br><span class="line">            if (service.app !&#x3D; null) &#123;</span><br><span class="line">                service.app.removed &#x3D; killProcess;</span><br><span class="line">                if (!service.app.persistent) &#123;</span><br><span class="line">                    service.app.services.remove(service);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            service.app &#x3D; null;</span><br><span class="line">            service.isolatedProc &#x3D; null;</span><br><span class="line">            if (mTmpCollectionResults &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mTmpCollectionResults &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;将满足条件service放入mTmpCollectionResults</span><br><span class="line">            mTmpCollectionResults.add(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的主要功能就是收集该满足条件service放入mTmpCollectionResults.</p>
<h3 id="5-3-bringDownServiceLocked"><a href="#5-3-bringDownServiceLocked" class="headerlink" title="5.3 bringDownServiceLocked"></a>5.3 bringDownServiceLocked</h3><p>[-&gt; ActiveServices.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final void bringDownServiceLocked(ServiceRecord r) &#123;</span><br><span class="line">    for (int conni&#x3D;r.connections.size()-1; conni&gt;&#x3D;0; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c &#x3D; r.connections.valueAt(conni);</span><br><span class="line">        for (int i&#x3D;0; i&lt;c.size(); i++) &#123;</span><br><span class="line">            ConnectionRecord cr &#x3D; c.get(i);</span><br><span class="line">            cr.serviceDead &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 断开service的连接</span><br><span class="line">            cr.conn.connected(r.name, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.app !&#x3D; null &amp;&amp; r.app.thread !&#x3D; null) &#123;</span><br><span class="line">        for (int i&#x3D;r.bindings.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">            IntentBindRecord ibr &#x3D; r.bindings.valueAt(i);</span><br><span class="line"></span><br><span class="line">            if (ibr.hasBound) &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, false, &quot;bring down unbind&quot;);</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">                ibr.hasBound &#x3D; false;</span><br><span class="line">                &#x2F;&#x2F;最终调用目标Service.onUnbind()方法</span><br><span class="line">                r.app.thread.scheduleUnbindService(r, ibr.intent.getIntent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.destroyTime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    final ServiceMap smap &#x3D; getServiceMap(r.userId);</span><br><span class="line">    smap.mServicesByName.remove(r.name);</span><br><span class="line">    smap.mServicesByIntent.remove(r.intent);</span><br><span class="line">    r.totalRestartCount &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; [见流程5.4]</span><br><span class="line">    unscheduleServiceRestartLocked(r, 0, true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;确保service不在pending队列</span><br><span class="line">    for (int i&#x3D;mPendingServices.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">        if (mPendingServices.get(i) &#x3D;&#x3D; r) &#123;</span><br><span class="line">            mPendingServices.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;取消service相关的通知</span><br><span class="line">    r.cancelNotification();</span><br><span class="line">    r.isForeground &#x3D; false;</span><br><span class="line">    r.foregroundId &#x3D; 0;</span><br><span class="line">    r.foregroundNoti &#x3D; null;</span><br><span class="line"></span><br><span class="line">    r.clearDeliveredStartsLocked();</span><br><span class="line">    r.pendingStarts.clear();</span><br><span class="line"></span><br><span class="line">    if (r.app !&#x3D; null) &#123;</span><br><span class="line">        synchronized (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        r.app.services.remove(r);</span><br><span class="line">        if (r.app.thread !&#x3D; null) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, false);</span><br><span class="line"></span><br><span class="line">            bumpServiceExecutingLocked(r, false, &quot;destroy&quot;);</span><br><span class="line">            mDestroyingServices.add(r);</span><br><span class="line">            r.destroying &#x3D; true;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#x2F;&#x2F; 最终调用目标service的onDestroy()</span><br><span class="line">            r.app.thread.scheduleStopService(r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.bindings.size() &gt; 0) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (r.restarter instanceof ServiceRestarter) &#123;</span><br><span class="line">       ((ServiceRestarter)r.restarter).setService(null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int memFactor &#x3D; mAm.mProcessStats.getMemFactorLocked();</span><br><span class="line">    long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">    if (r.tracker !&#x3D; null) &#123;</span><br><span class="line">        r.tracker.setStarted(false, memFactor, now);</span><br><span class="line">        r.tracker.setBound(false, memFactor, now);</span><br><span class="line">        if (r.executeNesting &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            r.tracker.clearCurrentOwner(r, false);</span><br><span class="line">            r.tracker &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    smap.ensureNotStartingBackground(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-unscheduleServiceRestartLocked"><a href="#5-4-unscheduleServiceRestartLocked" class="headerlink" title="5.4 unscheduleServiceRestartLocked"></a>5.4 unscheduleServiceRestartLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final boolean unscheduleServiceRestartLocked(ServiceRecord r, int callingUid, boolean force) &#123;</span><br><span class="line">    if (!force &amp;&amp; r.restartDelay &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将Services从重启列表移除,并重置重启计数器</span><br><span class="line">    boolean removed &#x3D; mRestartingServices.remove(r);</span><br><span class="line">    if (removed || callingUid !&#x3D; r.appInfo.uid) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    if (removed) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六-Provider"><a href="#六-Provider" class="headerlink" title="六. Provider"></a>六. Provider</h2><h3 id="6-1-PM-collectPackageProvidersLocked"><a href="#6-1-PM-collectPackageProvidersLocked" class="headerlink" title="6.1 PM.collectPackageProvidersLocked"></a>6.1 PM.collectPackageProvidersLocked</h3><p>[-&gt; ProviderMap.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean collectPackageProvidersLocked(String packageName, Set&lt;String&gt; filterByClasses, boolean doit, boolean evenPersistent, int userId, ArrayList&lt;ContentProviderRecord&gt; result) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    if (userId &#x3D;&#x3D; UserHandle.USER_ALL || userId &#x3D;&#x3D; UserHandle.USER_OWNER) &#123;</span><br><span class="line">        &#x2F;&#x2F; [见流程6.2]</span><br><span class="line">        didSomething &#x3D; collectPackageProvidersLocked(packageName, filterByClasses,</span><br><span class="line">                doit, evenPersistent, mSingletonByClass, result);</span><br><span class="line">    &#125;</span><br><span class="line">    if (!doit &amp;&amp; didSomething) &#123;</span><br><span class="line">        ... &#x2F;&#x2F;不进入该分支</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userId &#x3D;&#x3D; UserHandle.USER_ALL) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; mProvidersByClassPerUser.size(); i++) &#123;</span><br><span class="line">            if (collectPackageProvidersLocked(packageName, filterByClasses,</span><br><span class="line">                    doit, evenPersistent, mProvidersByClassPerUser.valueAt(i), result)) &#123;</span><br><span class="line">                ...</span><br><span class="line">                didSomething &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;从mProvidersByClassPerUser查询</span><br><span class="line">        HashMap&lt;ComponentName, ContentProviderRecord&gt; items</span><br><span class="line">                &#x3D; getProvidersByClass(userId);</span><br><span class="line">        if (items !&#x3D; null) &#123;</span><br><span class="line">            didSomething |&#x3D; collectPackageProvidersLocked(packageName, filterByClasses,</span><br><span class="line">                    doit, evenPersistent, items, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当userId = UserHandle.USER_ALL时, 则会<code>mSingletonByClass</code>和<code>mProvidersByClassPerUser</code>结构中查询所有属于该package的providers.</li>
<li>当userId = UserHandle.USER_OWNER时,则会从<code>mSingletonByClass</code>和<code>mProvidersByClassPerUser</code>中userId相等的 数据结构中查询所有属于该package的providers.</li>
<li>当userId不属于上述两者之一时,则会从<code>mProvidersByClassPerUser</code>中userId相等的查询所有属于该package的providers.</li>
</ul>
<h3 id="6-2-PM-collectPackageProvidersLocked"><a href="#6-2-PM-collectPackageProvidersLocked" class="headerlink" title="6.2 PM.collectPackageProvidersLocked"></a>6.2 PM.collectPackageProvidersLocked</h3><p>[-&gt; ProviderMap.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean collectPackageProvidersLocked(String packageName, Set&lt;String&gt; filterByClasses, boolean doit, boolean evenPersistent, HashMap&lt;ComponentName, ContentProviderRecord&gt; providers, ArrayList&lt;ContentProviderRecord&gt; result) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    for (ContentProviderRecord provider : providers.values()) &#123;</span><br><span class="line">        final boolean sameComponent &#x3D; packageName &#x3D;&#x3D; null</span><br><span class="line">                || (provider.info.packageName.equals(packageName)</span><br><span class="line">                    &amp;&amp; (filterByClasses &#x3D;&#x3D; null</span><br><span class="line">                        || filterByClasses.contains(provider.name.getClassName())));</span><br><span class="line">        if (sameComponent</span><br><span class="line">                &amp;&amp; (provider.proc &#x3D;&#x3D; null || evenPersistent || !provider.proc.persistent)) &#123;</span><br><span class="line">            if (!doit) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            didSomething &#x3D; true;</span><br><span class="line">            result.add(provider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-AMS-removeDyingProviderLocked"><a href="#6-3-AMS-removeDyingProviderLocked" class="headerlink" title="6.3 AMS.removeDyingProviderLocked"></a>6.3 AMS.removeDyingProviderLocked</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) &#123;</span><br><span class="line">     final boolean inLaunching &#x3D; mLaunchingProviders.contains(cpr);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;唤醒cpr, 并从mProviderMap中移除provider相关信息</span><br><span class="line">     if (!inLaunching || always) &#123;</span><br><span class="line">         synchronized (cpr) &#123;</span><br><span class="line">             cpr.launchingApp &#x3D; null;</span><br><span class="line">             cpr.notifyAll();</span><br><span class="line">         &#125;</span><br><span class="line">         mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));</span><br><span class="line">         String names[] &#x3D; cpr.info.authority.split(&quot;;&quot;);</span><br><span class="line">         for (int j &#x3D; 0; j &lt; names.length; j++) &#123;</span><br><span class="line">             mProviderMap.removeProviderByName(names[j], UserHandle.getUserId(cpr.uid));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     for (int i &#x3D; cpr.connections.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">         ContentProviderConnection conn &#x3D; cpr.connections.get(i);</span><br><span class="line">         if (conn.waiting) &#123;</span><br><span class="line">             &#x2F;&#x2F;always &#x3D; true,不进入该分支</span><br><span class="line">             if (inLaunching &amp;&amp; !always) &#123;</span><br><span class="line">                 continue;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         ProcessRecord capp &#x3D; conn.client;</span><br><span class="line">         conn.dead &#x3D; true;</span><br><span class="line">         if (conn.stableCount &gt; 0) &#123;</span><br><span class="line">             if (!capp.persistent &amp;&amp; capp.thread !&#x3D; null</span><br><span class="line">                     &amp;&amp; capp.pid !&#x3D; 0</span><br><span class="line">                     &amp;&amp; capp.pid !&#x3D; MY_PID) &#123;</span><br><span class="line">                 &#x2F;&#x2F;杀掉依赖该provider的client进程</span><br><span class="line">                 capp.kill(&quot;depends on provider &quot;</span><br><span class="line">                         + cpr.name.flattenToShortString()</span><br><span class="line">                         + &quot; in dying proc &quot; + (proc !&#x3D; null ? proc.processName : &quot;??&quot;), true);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else if (capp.thread !&#x3D; null &amp;&amp; conn.provider.provider !&#x3D; null) &#123;</span><br><span class="line">             capp.thread.unstableProviderDied(conn.provider.provider.asBinder());</span><br><span class="line">             cpr.connections.remove(i);</span><br><span class="line">             if (conn.client.conProviders.remove(conn)) &#123;</span><br><span class="line">                 stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (inLaunching &amp;&amp; always) &#123;</span><br><span class="line">         mLaunchingProviders.remove(cpr);</span><br><span class="line">     &#125;</span><br><span class="line">     return inLaunching;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当其他app使用该provider, 且建立stable的连接, 那么对于非persistent进程,则会由于依赖该provider的缘故而被杀.</p>
<h2 id="七-Broadcast"><a href="#七-Broadcast" class="headerlink" title="七. Broadcast"></a>七. Broadcast</h2><h3 id="7-1-BQ-cleanupDisabledPackageReceiversLocked"><a href="#7-1-BQ-cleanupDisabledPackageReceiversLocked" class="headerlink" title="7.1 BQ.cleanupDisabledPackageReceiversLocked"></a>7.1 BQ.cleanupDisabledPackageReceiversLocked</h3><p>[-&gt; BroadcastQueue.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean cleanupDisabledPackageReceiversLocked( String packageName, Set&lt;String&gt; filterByClasses, int userId, boolean doit) &#123;</span><br><span class="line">    boolean didSomething &#x3D; false;</span><br><span class="line">    for (int i &#x3D; mParallelBroadcasts.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        &#x2F;&#x2F; 【见流程7.2】</span><br><span class="line">        didSomething |&#x3D; mParallelBroadcasts.get(i).cleanupDisabledPackageReceiversLocked(</span><br><span class="line">                packageName, filterByClasses, userId, doit);</span><br><span class="line">        if (!doit &amp;&amp; didSomething) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; mOrderedBroadcasts.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        didSomething |&#x3D; mOrderedBroadcasts.get(i).cleanupDisabledPackageReceiversLocked(</span><br><span class="line">                packageName, filterByClasses, userId, doit);</span><br><span class="line">        if (!doit &amp;&amp; didSomething) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要功能：</p>
<ul>
<li>清理并行广播队列mParallelBroadcasts；</li>
<li>清理有序广播队列mOrderedBroadcasts</li>
</ul>
<h3 id="7-2-BR-cleanupDisabledPackageReceiversLocked"><a href="#7-2-BR-cleanupDisabledPackageReceiversLocked" class="headerlink" title="7.2 BR.cleanupDisabledPackageReceiversLocked"></a>7.2 BR.cleanupDisabledPackageReceiversLocked</h3><p>[-&gt; BroadcastRecord.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean cleanupDisabledPackageReceiversLocked( String packageName, Set&lt;String&gt; filterByClasses, int userId, boolean doit) &#123;</span><br><span class="line">   if ((userId !&#x3D; UserHandle.USER_ALL &amp;&amp; this.userId !&#x3D; userId) || receivers &#x3D;&#x3D; null) &#123;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   boolean didSomething &#x3D; false;</span><br><span class="line">   Object o;</span><br><span class="line">   for (int i &#x3D; receivers.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">       o &#x3D; receivers.get(i);</span><br><span class="line">       if (!(o instanceof ResolveInfo)) &#123;</span><br><span class="line">           continue;</span><br><span class="line">       &#125;</span><br><span class="line">       ActivityInfo info &#x3D; ((ResolveInfo)o).activityInfo;</span><br><span class="line"></span><br><span class="line">       final boolean sameComponent &#x3D; packageName &#x3D;&#x3D; null</span><br><span class="line">               || (info.applicationInfo.packageName.equals(packageName)</span><br><span class="line">               &amp;&amp; (filterByClasses &#x3D;&#x3D; null || filterByClasses.contains(info.name)));</span><br><span class="line">       if (sameComponent) &#123;</span><br><span class="line">           ...</span><br><span class="line">           didSomething &#x3D; true;</span><br><span class="line">           &#x2F;&#x2F;移除该广播receiver</span><br><span class="line">           receivers.remove(i);</span><br><span class="line">           if (i &lt; nextReceiver) &#123;</span><br><span class="line">               nextReceiver--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   nextReceiver &#x3D; Math.min(nextReceiver, receivers.size());</span><br><span class="line">   return didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八-Alarm和Notification"><a href="#八-Alarm和Notification" class="headerlink" title="八. Alarm和Notification"></a>八. Alarm和Notification</h2><p>在前面[小节2.2]介绍到处理完forceStopPackageLocked()，紧接着便是发送广播<code>ACTION_PACKAGE_RESTARTED</code>，经过<a href="http://gityuan.com/2016/06/04/broadcast-receiver/" target="_blank" rel="noopener">Broadcast广播分发</a>，最终调用到注册过该广播的接收者。</p>
<h3 id="8-1-Alarm清理"><a href="#8-1-Alarm清理" class="headerlink" title="8.1 Alarm清理"></a>8.1 Alarm清理</h3><p>[-&gt; AlarmManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UninstallReceiver extends BroadcastReceiver &#123;</span><br><span class="line">   public UninstallReceiver() &#123;</span><br><span class="line">       IntentFilter filter &#x3D; new IntentFilter();</span><br><span class="line">       filter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">       &#x2F;&#x2F;监听ACTION_PACKAGE_RESTARTED</span><br><span class="line">       filter.addAction(Intent.ACTION_PACKAGE_RESTARTED);</span><br><span class="line">       filter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">       filter.addDataScheme(&quot;package&quot;);</span><br><span class="line">       getContext().registerReceiver(this, filter);</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           String action &#x3D; intent.getAction();</span><br><span class="line">           String pkgList[] &#x3D; null;</span><br><span class="line">           if (Intent.ACTION_QUERY_PACKAGE_RESTART.equals(action)) &#123;</span><br><span class="line">               ...</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               ...</span><br><span class="line">               Uri data &#x3D; intent.getData();</span><br><span class="line">               if (data !&#x3D; null) &#123;</span><br><span class="line">                   String pkg &#x3D; data.getSchemeSpecificPart();</span><br><span class="line">                   if (pkg !&#x3D; null) &#123;</span><br><span class="line">                       pkgList &#x3D; new String[]&#123;pkg&#125;;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (pkgList !&#x3D; null &amp;&amp; (pkgList.length &gt; 0)) &#123;</span><br><span class="line">               for (String pkg : pkgList) &#123;</span><br><span class="line">                   &#x2F;&#x2F;移除alarm</span><br><span class="line">                   removeLocked(pkg);</span><br><span class="line">                   mPriorities.remove(pkg);</span><br><span class="line">                   for (int i&#x3D;mBroadcastStats.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">                       ArrayMap&lt;String, BroadcastStats&gt; uidStats &#x3D; mBroadcastStats.valueAt(i);</span><br><span class="line">                       if (uidStats.remove(pkg) !&#x3D; null) &#123;</span><br><span class="line">                           if (uidStats.size() &lt;&#x3D; 0) &#123;</span><br><span class="line">                               mBroadcastStats.removeAt(i);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;    &#125;</span><br></pre></td></tr></table></figure>

<p>调用AlarmManagerService中的removeLocked()方法，从<code>mAlarmBatches</code>和<code>mPendingWhileIdleAlarms</code>队列中移除包所相关的alarm.</p>
<h3 id="8-2-Notification清理"><a href="#8-2-Notification清理" class="headerlink" title="8.2 Notification清理"></a>8.2 Notification清理</h3><p>[-&gt; NotificationManagerService.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final BroadcastReceiver mPackageIntentReceiver &#x3D; new BroadcastReceiver() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">        String action &#x3D; intent.getAction();</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        if (action.equals(Intent.ACTION_PACKAGE_ADDED)</span><br><span class="line">                || (queryRemove&#x3D;action.equals(Intent.ACTION_PACKAGE_REMOVED))</span><br><span class="line">                || action.equals(Intent.ACTION_PACKAGE_RESTARTED)</span><br><span class="line">                || (packageChanged&#x3D;action.equals(Intent.ACTION_PACKAGE_CHANGED))</span><br><span class="line">                || (queryRestart&#x3D;action.equals(Intent.ACTION_QUERY_PACKAGE_RESTART))</span><br><span class="line">                || action.equals(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE)) &#123;</span><br><span class="line">            int changeUserId &#x3D; intent.getIntExtra(Intent.EXTRA_USER_HANDLE,</span><br><span class="line">                    UserHandle.USER_ALL);</span><br><span class="line">            String pkgList[] &#x3D; null;</span><br><span class="line">            boolean queryReplace &#x3D; queryRemove &amp;&amp;</span><br><span class="line">                    intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span><br><span class="line">            if (action.equals(Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE)) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Uri uri &#x3D; intent.getData();</span><br><span class="line">                ...</span><br><span class="line">                String pkgName &#x3D; uri.getSchemeSpecificPart();</span><br><span class="line">                if (packageChanged) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                pkgList &#x3D; new String[]&#123;pkgName&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (pkgList !&#x3D; null &amp;&amp; (pkgList.length &gt; 0)) &#123;</span><br><span class="line">                for (String pkgName : pkgList) &#123;</span><br><span class="line">                    if (cancelNotifications) &#123;</span><br><span class="line">                        &#x2F;&#x2F;移除Notification</span><br><span class="line">                        cancelAllNotificationsInt(MY_UID, MY_PID, pkgName, 0, 0, !queryRestart,</span><br><span class="line">                                changeUserId, REASON_PACKAGE_CHANGED, null);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mListeners.onPackagesChanged(queryReplace, pkgList);</span><br><span class="line">            mConditionProviders.onPackagesChanged(queryReplace, pkgList);</span><br><span class="line">            mRankingHelper.onPackagesChanged(queryReplace, pkgList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用NotificationManagerService.java 中的cancelAllNotificationsInt()方法，从<code>mNotificationList</code>队列中移除包所相关的Notification.</p>
<h2 id="九-级联诛杀"><a href="#九-级联诛杀" class="headerlink" title="九. 级联诛杀"></a>九. 级联诛杀</h2><p>这里就跟大家分享一段经历吧，记得之前有BAT的某浏览器大厂(具体名称就匿了)，浏览器会因为另一个app被杀而导致自己无辜被牵连所杀，并怀疑是ROM定制化导致的bug，于是发邮件向我厂请教缘由。</p>
<p>遇到这个问题，首先将两个app安装到Google原生系统，结果是依然会被级联诛杀，很显然可以排除厂商ROM定制的缘故，按常理说bug应该可以让app自行解决。出于好奇，帮他们进一步调查了下这个问题，发现并非无辜被杀，而是force-stop的级联诛杀所导致的。</p>
<p>简单来说就是App1调用了getClassLoader()来加载App2，那么App1所运行的进程便会在其<code>pkgDeps</code>队列中增加App2的包名，在前面[小节3.2]已经提到<code>pkgDeps</code>，杀进程的过程中会遍历该队列，当App2被forceStop所杀时，便是级联诛杀App1。App1既然会调用App2的ClassLoader来加载其方法，那么就建立了一定的联系，这是Google有意赋予forceStop这个强力杀的功能。</p>
<p>这个故事是想告诉大家在插件化或者反射的过程中要注意这种情况，防止不必要的误伤。接下来具体说说这个过程是如何建立依赖的。</p>
<h3 id="9-1-CI-getClassLoader"><a href="#9-1-CI-getClassLoader" class="headerlink" title="9.1 CI.getClassLoader"></a>9.1 CI.getClassLoader</h3><p>[-&gt; ContextImpl.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    &#x2F;&#x2F;【见小节9.2】</span><br><span class="line">   return mPackageInfo !&#x3D; null ?</span><br><span class="line">             mPackageInfo.getClassLoader() : ClassLoader.getSystemClassLoader();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-LA-getClassLoader"><a href="#9-2-LA-getClassLoader" class="headerlink" title="9.2 LA.getClassLoader"></a>9.2 LA.getClassLoader</h3><p>[-&gt; LoadedApk.java]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ClassLoader getClassLoader() &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mClassLoader !&#x3D; null) &#123;</span><br><span class="line">            return mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mPackageName.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            if (mBaseClassLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mClassLoader &#x3D; ClassLoader.getSystemClassLoader();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mClassLoader &#x3D; mBaseClassLoader;</span><br><span class="line">            &#125;</span><br><span class="line">            return mClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mRegisterPackage) &#123;</span><br><span class="line">            &#x2F;&#x2F;经过Binder，最终调用到AMS.addPackageDependency 【见小节9.3】</span><br><span class="line">            ActivityManagerNative.getDefault().addPackageDependency(mPackageName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        mClassLoader &#x3D; ApplicationLoaders.getDefault().getClassLoader(zip,</span><br><span class="line">                mApplicationInfo.targetSdkVersion, isBundledApp, librarySearchPath,</span><br><span class="line">                libraryPermittedPath, mBaseClassLoader);</span><br><span class="line"></span><br><span class="line">        return mClassLoader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-AMS-addPackageDependency"><a href="#9-3-AMS-addPackageDependency" class="headerlink" title="9.3 AMS.addPackageDependency"></a>9.3 AMS.addPackageDependency</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void addPackageDependency(String packageName) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        int callingPid &#x3D; Binder.getCallingPid();</span><br><span class="line">        if (callingPid &#x3D;&#x3D; Process.myPid()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ProcessRecord proc;</span><br><span class="line">        synchronized (mPidsSelfLocked) &#123;</span><br><span class="line">            proc &#x3D; mPidsSelfLocked.get(Binder.getCallingPid());</span><br><span class="line">        &#125;</span><br><span class="line">        if (proc !&#x3D; null) &#123;</span><br><span class="line">            if (proc.pkgDeps &#x3D;&#x3D; null) &#123;</span><br><span class="line">                proc.pkgDeps &#x3D; new ArraySet&lt;String&gt;(1);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;将该包名添加到pkgDeps</span><br><span class="line">            proc.pkgDeps.add(packageName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用ClassLoader来加载启动包名时，则会将该包名加入到进程的pkgDeps。</p>
<h2 id="十-总结"><a href="#十-总结" class="headerlink" title="十. 总结"></a>十. 总结</h2><p>forceStop的功能如下：</p>
<p><img src="http://gityuan.com/images/process/force_stop.jpg" alt="force_stop"></p>
<ol>
<li>Process: 调用AMS.killPackageProcessesLocked()清理该package所涉及的进程;</li>
<li>Activity: 调用ASS.finishDisabledPackageActivitiesLocked()清理该package所涉及的Activity;</li>
<li>Service: 调用AS.bringDownDisabledPackageServicesLocked()清理该package所涉及的Service;</li>
<li>Provider: 调用AMS.removeDyingProviderLocked()清理该package所涉及的Provider;</li>
<li>BroadcastRecevier: 调用BQ.cleanupDisabledPackageReceiversLocked()清理该package所涉及的广播</li>
<li>发送广播ACTION_PACKAGE_RESTARTED，用于停止已注册的alarm,notification.</li>
</ol>
<p>persistent进程的特殊待遇:</p>
<ul>
<li>进程: AMS.killPackageProcessesLocked()不杀进程</li>
<li>Service: ActiveServices.collectPackageServicesLocked()不移除不清理service</li>
<li>Provider: ProviderMap.collectPackageProvidersLocked()不收集不清理provider. 且不杀该provider所连接的client的persistent进程;</li>
<li></li>
</ul>
<p><strong>功能点归纳：</strong></p>
<ol>
<li>force-stop并不会杀persistent进程；</li>
<li>当app被force-stop后，无法接收到任何普通广播，那么也就常见的监听手机网络状态的变化或者屏幕亮灭的广播来拉起进程肯定是不可行；</li>
<li>当app被force-stop后，那么alarm闹钟一并被清理，无法实现定时响起的功能；</li>
<li>app被force-stop后，四大组件以及相关进程都被一一剪除清理，即便多进程架构的app也无法拉起自己；</li>
<li>级联诛杀：当app通过ClassLoader加载另一个app，则会在force-stop的过程中会被级联诛杀；</li>
<li>生死与共：当app与另个app使用了share uid，则会在force-stop的过程，任意一方被杀则另一方也被杀，建立起生死与共的强关系。</li>
</ol>
<p>既然force-stop多次提到杀进程，那最后简单说两句关于保活：<strong>正确的保活姿态，应该是在用户需要时保证千万别被杀，用户不需要时别强保活，一切以用户为出发点。</strong></p>
<ul>
<li>进程是否需要存活，系统上层有AMS来管理缓存进程和空进程，底层有LowMemoryKiller来根据系统可用内存的情况来管理进程是否存活，这样的策略是从系统整体性角度考虑，为了是给用户提供更好更流畅的用户体验。</li>
<li>用户需要的时候千万别被杀：谨慎使用插件化和共享uid，除非愿意接受级联诛杀和生死与共的场景；还有就是提高自身app的稳定性，减少crash和anr的发生频率，这才是正道。</li>
<li>用户不需要的时候别强保活：为了保活，多进程架构，利用各种小技巧来提升优先级等都是不可取的，一招force-stop足以干掉90%以上的保活策略，当然还有一些其他手段及漏洞来保活，系统层面往往还会采取一些特别的方法来禁止保活。博主曾经干过手机底层的性能与功耗优化工作，深知不少app的流氓行径，严重系统的流畅度与手机续航能力。</li>
</ul>
<p>为了android有更好的用户体验，为了不影响手机系统性能，为了不降低手机续航能力，建议大家花更多时间精力在如何提高app的稳健性，如何优化app性能，共同打造Android的良好生态圈。</p>
]]></content>
  </entry>
  <entry>
    <title>【转载】字节跳动为什么选用Flutter：并非跨平台终极之选，但它可能是不一样的未来</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E7%94%A8Flutter%EF%BC%9A%E5%B9%B6%E9%9D%9E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BB%88%E6%9E%81%E4%B9%8B%E9%80%89%EF%BC%8C%E4%BD%86%E5%AE%83%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<blockquote>
<p>2018 年 12 月 ，Google 宣布 Flutter 1.0 版本正式发布。截至目前， Flutter 在 Github 上已获得 88000+ 的关注和 11000+ 的 Fork ，其发展速度相当惊人，是今年移动端最火热的开发框架之一。</p>
</blockquote>
<p>Flutter 大火背后的原因是什么？为什么越来越多的企业和开发者会选择使用 Flutter？Flutter 会成为跨平台开发的终极之选吗？我认为“ Flutter 并非跨平台终极之选，最初选择 Flutter，不是因为它一定会成为未来终极之选，而是因为它有可能成为不一样的未来。”</p>
<h2 id="Flutter-大火的原因"><a href="#Flutter-大火的原因" class="headerlink" title="Flutter 大火的原因"></a>Flutter 大火的原因</h2><p>有人说 Flutter 大火主要原因是它选择了 Dart 语言，Dart 有着高性能的表现和可快速分配内存的能力，能同时支持 JIT 和 AOT 模式，允许在带类型的语言中支持形变和有状态热重载，能编译出高效率的 ARM 机器码指令，Dart 作为面向对象的语言也能让绝大多数开发者更快速上手。我认可 Dart 语言有一定的优势，但这样的优势并非 Dart 独有，我想这更不会是大家选择 Flutter 的核心原因，这是因果倒置。事实上，Dart 是 2011 年推出的，在 Flutter 出现之前，Dart 曾一度几乎被人遗忘。正是因为近年来 Flutter 的火爆，才让 Dart 重新进入大众的视线。Flutter 当初选择 Dart，或者仅因为 Google 的 Flutter 和 Dart 这两个团队离得比较近，交流比较方便。 我认为 Flutter 之所以大火，主要是以下几个原因：</p>
<h4 id="1-现有跨平台技术存在缺陷"><a href="#1-现有跨平台技术存在缺陷" class="headerlink" title="1. 现有跨平台技术存在缺陷"></a>1. 现有跨平台技术存在缺陷</h4><p>在移动互联网时代，Android 和 iOS 两大阵营长期共存，再加上体系成熟的 Web 前端技术，导致出现同一个应用需多端重复开发的人力成本问题。正因如此，移动时代下的跨平台技术是一个需要长期研究的课题。如果当下的跨平台技术已经有比较完美的解决方案，可能就没有新技术萌芽的机会。而事实上，目前业界比较成熟的跨平台技术都存在一定的缺陷，比如小程序（WebView）渲染耗时过长，白屏率会影响转化收益，能实现的功能非常受限；再比如 React Native 的性能不足、问题排除难、维护成本高等。而 Flutter 的出现，让这些跨平台开发问题有所改善，它还是 Google 开源的技术，自身也具备一定的热度。另外，一直备受关注且神秘的 Fuchsia 系统在 UI 框架上使用的也是 Flutter，可作为长期战略投入，这也增强了大家对 Flutter 的信心。</p>
<h4 id="2-研发效率就是竞争力"><a href="#2-研发效率就是竞争力" class="headerlink" title="2. 研发效率就是竞争力"></a>2. 研发效率就是竞争力</h4><p>移动互联网进入下半场，出现一些新兴互联网独角兽、小巨头，在没有历史包袱的情况下，更愿意尝试技术上限更高的新技术。从校招和社招的难度上不难发现：客户端的人才相比之前更为稀缺，尤其是 iOS 工程师。而下半场会有更多竞争和更为激烈的赛道，比如教育等方向。Flutter 本身非常适合从零开始的没有历史包袱的应用开发，对于新业务尤其是在团队人力紧缺的情况下，在技术选型上考虑 Flutter，能加快产品在多端落地、快速试错。</p>
<h4 id="3-集漂亮与流畅集于一身"><a href="#3-集漂亮与流畅集于一身" class="headerlink" title="3. 集漂亮与流畅集于一身"></a>3. 集漂亮与流畅集于一身</h4><p>Flutter “一出生”就以“UI 漂亮、像素级可控、性能流畅、可媲美原生性能”等特点吸引广大开发者的眼球，自渲染引擎甚至具备开发游戏的能力。移动下半场，没有人口红利，竞争更为激烈，如何能更好地满足用户对高品质、高流畅的需求，便是移动端一种强有力的竞争力。跨平台技术想要拥有更高的流畅度，采用自渲染技术的方案便是更优解，也是一个更为彻底的跨平台技术方向。</p>
<h2 id="字节跳动选择-Flutter-的初心"><a href="#字节跳动选择-Flutter-的初心" class="headerlink" title="字节跳动选择 Flutter 的初心"></a>字节跳动选择 Flutter 的初心</h2><p>说到这里，先分享一下 Flutter 最初是如何诞生的故事。Flutter 创始人 Eric 之前在 Chrome 团队工作，期间遇到一些难以解决的问题， 希望 Web 中的一部分能够拥有更加平滑的体验， 为此他花了几周时间做了一个实验，不考虑 Web 的兼容方式，删除了大量为了兼容访问的代码和一些 Web 开发者不常用的功能， 删除到有不少 Web 元素的渲染已经不支持了，然后做了一个基准测试，得出结论是某些关注指标的速度快了 20 倍。于是，Eric 决定再做点什么，后面投入了大量研究和开发，便有了现在的 Flutter 。</p>
<p>听到这里给人的感觉是，对于 Web 工程师而言 Flutter 应该容易上手。我跟公司很多正在使用或者调研 Flutter 的业务团队做过沟通，发现客户端比前端的同学对 Flutter 接受度更高，我个人从 Android 端技术出身，的确觉得学习 Flutter 还是非常容易上手的，但公司内前端的同学对 Flutter 使用的吐槽会多一点。所以，我认为 Flutter 更像是以客户端视角的跨平台技术，Flutter 与其说是大前端技术，不如说是大移动端技术。Flutter 发展的 Roadmap 也是先全面支持 Android/iOS 端能力，再进一步完善 Web 端能力支持的。</p>
<p>字节跳动对于客户端技术还是非常重视的，字节跳动有很多客户端工程师，之前客户端深入点的基础技术更多是搞插件化、热修复、性能优化、安全加固等，跨平台方向一直都是前端工程师在不遗余力地推进，属于大前端方向。而 Flutter 是客户端更有主导的跨平台技术方案。另外说明，字节跳动并不是说只有一套跨平台技术栈，公司内部也是多套跨端技术栈并存，也包括自研的方案。</p>
<p>在字节跳动，跨平台技术并没有形成大规模的落地，之前也提到没有历史包袱，所以在面对跨平台技术选型的时候，更关注跨平台技术的技术上限以及发展潜力，自渲染技术的 Flutter 可以理解为更彻底更纯粹的跨平台技术，伴随着媲美原生的流畅度，这便是我们选择 Flutter 的初心。</p>
<h2 id="Flutter-落地过程中的“坑”"><a href="#Flutter-落地过程中的“坑”" class="headerlink" title="Flutter 落地过程中的“坑”"></a>Flutter 落地过程中的“坑”</h2><p>截至目前，字节跳动有很多业务落地了 Flutter 技术方案，包括今日头条、西瓜视频、皮皮虾等 20 多个业务在使用 Flutter 开发，有纯 Flutter 工程，也有 Flutter 与 Native 的混合工程。如果大家想要了解更多业务落地情况，后续我会在今年的 QCon 北京 2020 大会上分享。</p>
<p>Flutter 虽潜力上限很高，但仍需打磨和雕琢，我们在 Flutter 推动过程中遇到很多问题，比如包体积过大的问题、性能达不到预期、对混合工程的支持不够友好、各宿主 Flutter 引擎版本不一致、基础库不完善、Flutter 改造后各项数据打平等。除此之外，还有很多非技术的困难，比如业务团队并不认可 Flutter 新技术，工程师缺乏 Flutter 经验，担忧审核风险等，都会影响业务方是否采用 Flutter 技术，每一个困难都需要去解决，不然就难以落地。下面就其中两个难点，我来展开聊一下。</p>
<h4 id="1-包体积问题"><a href="#1-包体积问题" class="headerlink" title="1. 包体积问题"></a>1. 包体积问题</h4><p>字节跳动内的大型 APP，比如今日头条、抖音等对包体积的增量非常敏感，Flutter 的包体积涉及两个部分，一个是一次性 Flutter 引擎的包体积问题，一个是每次写 Dart 代码比写 OC 代码代码增量的问题。这两个问题对我们来说都非常棘手，我们成立了包体积优化专项进行全力攻坚，同时跟 Google 工程师多次会议沟通，不断精简包体积。最终我们通过一系列优化手段，包含 Data 压缩、编译优化、Skia 裁剪、BoringSSL/ICU 库 / 文字渲染 /libwebp 等库裁剪取得了不少的效果；通过实践我们发现用 OC 代码和 Dart 代码写相同的业务逻辑，Dart 生成的机器码指令比 OC 多，主要在生成的二进制指令头、指令冗余、指令对齐的精简，以及 StackMap 和 CodeSourceMap 的精简等方面。同时我们也向 Google 反馈了这些情况。关于指令精简，可以查看 Issue 进展，里面有记录详细的推进过程： <a href="https://github.com/flutter/flutter/issues/40345" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/40345</a></p>
<h4 id="2-性能优化问题"><a href="#2-性能优化问题" class="headerlink" title="2. 性能优化问题"></a>2. 性能优化问题</h4><p>这是我们遇到的棘手问题之一，我们用 Flutter 官方提供的性能分析工具 Timeline 来分析一个比较诡异的性能问题，始终无法发现任何异常。困扰已久，后来干脆重新撸了一遍 Timeline 整个性能分析工具的源码，最终找到了其缺陷，并向 Flutter 社区提及，合入了 10 个 PR ，基于此让我有幸成为了 Flutter Member ，后续会持续向社区贡献更多力量：<a href="https://github.com/flutter/flutter/issues/47771" target="_blank" rel="noopener">https://github.com/flutter/flutter/issues/47771</a>.</p>
<p>Flutter 是一个自渲染的跨平台技术，有着很高的性能上限，但并不代表现在性能各方面都很优秀，毕竟 Flutter 作为一个“新生儿”，还是有一些需要进一步改造的地方。除性能工具改造之外，其实在 Flutter 落地场景中，我们也解决了不少性能问题，同时优化了自身的引擎，比如 UI 预加载策略、Flutter Turbo 技术、Vsync 调度策略等，让引擎提速，争取让 Flutter 性能发挥到极致。</p>
<h2 id="Flutter-在业务层面的发展阻力"><a href="#Flutter-在业务层面的发展阻力" class="headerlink" title="Flutter 在业务层面的发展阻力"></a>Flutter 在业务层面的发展阻力</h2><p>引入 Flutter 之后，在公司的业务也创造了不少价值。主要体现在这几个方面：其一，Flutter 多端一致性上表现良好，能做到所见即所得，无需针对某一平台做额外适配工作；其二，热重载技术使得设计团队和工程团队可以非常快速的修改和调试 UI，设计师只需要关注一个平台实现，UI 验收效率明显提高，跨端开发可以提高工程师的人效（有团队初步估算人效大致提升了 1.8 倍）；其三，性能流畅度提升，相较于 H5 版本首屏时间有较大提升，最后，产品商业化数据都有明显的收益，能直观地看到 Flutter 给公司带来的创收。</p>
<p>不过，现阶段 Flutter 的发展仍有一些阻力：</p>
<h4 id="1-Flutter-采用的是-Dart-语言，没能引入前端成熟的生态体系"><a href="#1-Flutter-采用的是-Dart-语言，没能引入前端成熟的生态体系" class="headerlink" title="1. Flutter 采用的是 Dart 语言，没能引入前端成熟的生态体系"></a>1. Flutter 采用的是 Dart 语言，没能引入前端成熟的生态体系</h4><p>作为前端工程师可能更希望是 Flutter 上层采用的是 JavaScript 或者 TypeScript，未来可考虑提供高性能的 Dart 与 JS 互转能力。另外，Flutter 开发对于前端开发工程师而言，还是有一些挑战的，纯前端不一定能 Cover 的技术，比如 Flutter 的一个硬件相关的 Plugin 只在某款手机出现 Bug，如果社区没有现存解决方案，可能就需要花比较大的时间成本去学习 Native 技术，或者请教客户端工程师。</p>
<h4 id="2-开源库相对比较欠缺，更新频次不足"><a href="#2-开源库相对比较欠缺，更新频次不足" class="headerlink" title="2. 开源库相对比较欠缺，更新频次不足"></a>2. 开源库相对比较欠缺，更新频次不足</h4><p>Flutter 生态还不够完善，新业务接入需要自己造轮子，尤其是在业务团队对 Flutter 掌握不够熟练的情况下，会增加额外的成本，Flutter 在大中型企业会更容易推广起来，有人力可以去造轮子让公司内其他的业务复用；另外，Flutter 文档有点少，能借鉴的经验不多，未来需加强和鼓励更多开发者加入到生态共建。</p>
<h4 id="3-跟原生系统生态存在着一定的竞争关系"><a href="#3-跟原生系统生态存在着一定的竞争关系" class="headerlink" title="3. 跟原生系统生态存在着一定的竞争关系"></a>3. 跟原生系统生态存在着一定的竞争关系</h4><p>有朋友跟我说起过这样一件事，看到 Flutter 这么火，Android 开发团队就问他，“大家为什么要用 Flutter 开发 App，我们 Android 哪一点不好，告诉我们，我们可以改进它”。姑且不说他们对跨平台理解不够，但至少能看出原生平台对跨端技术的担忧，不少 Android 团队在推出 Kotlin Multiplatform ，希望能争夺更多市场。 另外，苹果商店的审核风险也是大家所担忧的，官方的公告原意是说应用程序的核心特性和功能必须包含在软件的二进制文件中，而不是通过类似 HTML5 的技术来实现动态更新，苹果要打压的是动态更新技术，考虑到 Flutter 的合规性，Google 主动把 Flutter 的 iOS 动态化能力去掉了，Flutter 最终打包生成的产物就是 IPA，Flutter 其实是完全符合规范的，甚至还有使用 Flutter 开发的应用还被 Apple 推荐过。相反，React Native、Weex、H5 等技术都是一种动态化解决方案，这正是苹果要管控的，目前苹果的态度更多的是不提倡，但也不保证不封杀。即便如此，苹果不希望原生开发生态被其他跨平台技术抢占，苹果也在不断推行 SwiftUI 框架，力图抵挡 Flutter 等跨平台技术对原生开发的蚕食。Flutter 未来要加强推进步伐，让更多的大型 App 通过 Flutter 技术得到收益，只有用户群体上来，未来的地位和话语权才会更高，就像现在小程序，原则上是不符合苹果的审核要求的，但各大型应用基本都上线了小程序功能，目前来看不至于说苹果把小程序直接干掉。</p>
<h2 id="Flutter-并非跨平台终极之选"><a href="#Flutter-并非跨平台终极之选" class="headerlink" title="Flutter 并非跨平台终极之选"></a>Flutter 并非跨平台终极之选</h2><p>从 Hybrid App 到 React Native，再到 Flutter，跨平台技术层出不穷。目前来看，Flutter 是跨平台开发的最热门技术，但我并不认为 Flutter 就一定是跨平台开发的终极之选，它有着历史局限性，我只能说 Flutter 可能是当下最有潜力的跨平台技术。如果你对性能流畅度有高要求，或者有多个产品希望快速在多端试错迭代，我会推荐你尝试 Flutter。</p>
<p>未来一段时间，还应该是多套跨平台技术并存的时代， 目前 Flutter 也没有全面做到可以碾压其他跨平台技术，可根据团队以及业务特点来考虑更适合的方案。有一定客户端经验的同学入手 Flutter 会更快一些，如果团队在 React Native 上有很好落地，业务没有遇到性能等瓶颈，且团队缺少客户端能力，建议先做技术调研和沉淀，不要盲目追求新技术，只有当团队有能力且业务有需求的情况下，建议再考虑切换技术栈。</p>
<p>我们前面提到过，一直备受关注且神秘的 Fuchsia 系统在 UI 框架上使用的也是 Flutter。Fuchsia 是 Google 开发的下一代操作系统。Fuchsia 是采用全新模块化设计思想、跨平台框架技术的系统。它能支持快捷裁剪定制，更能适应未来的多元化设备，包含手机、平板、笔记本、路由器、智能设备、机器人等，Fuchsia 有可能成为一个全新的跨全平台的通用操作系统。</p>
<p>在现阶段，开始尝试探索和积累沉淀 Flutter 技术能力，并在业务上使用 Flutter 技术的应用，从战略上来将已经处于领先。选择 Flutter，正可谓是“进可攻退可守”，往前进一步，Flutter 应用未来可无缝迁移到 Fuchsia 系统，借用 Fuchsia 系统的能量扩展到更广泛的用户场景；退一步，Flutter 技术自身在 Android/iOS 平台的表现相比其他跨平台技术已经是很优秀。</p>
<p>最初选择 Flutter，不是因为它一定会成为未来终极之选，而是它有可能成为不一样的未来。</p>
<h2 id="Flutter-展望：终将走向多端一体化"><a href="#Flutter-展望：终将走向多端一体化" class="headerlink" title="Flutter 展望：终将走向多端一体化"></a>Flutter 展望：终将走向多端一体化</h2><p>回顾整移动操作系统的演变历程，从塞班功能机到 Android/iOS 智能机，从小屏手机到全面屏、刘海屏、水滴屏。任何系统的演变最终体现在输入和输出两个环节，接收到输入信号后经过操作系统处理后输出信息给用户。从按键式交互到触屏式交互，伴随着塞班系统到 Android 系统的转变，未来的交互方式一定会更加生物智能化，当下的触屏交互可以理解成人类的触觉输入方式，未来将朝着人们更常见的听觉（语音）输入和视觉（身体姿势、表情等）输入，甚至嗅觉（气味变化）输入，这些都会伴随着新的操作系统而诞生。屏幕从小尺寸到大尺寸，并没有引发操作系统变革，因为技术创新是非连续性，非连续性才会引发第二曲线，诞生新技术。从 1960 年大型机，到 1990 年个人笔记本，再到现在的智能手机，设备本身越来越小。未来的设备如果发展非连续变革，可能不再需要实体硬件，随处可输出，一张白纸、一面墙，到那时操作系统的 UI 架构必然会有全新的变化。</p>
<p>随着科技的发展，5G 时代的到来，人工智能的日趋成熟，端到底会有哪些变化？是否会出现新的操作系统？系统的 UI 架构是否会出现新的变革？Android/iOS 平台是否能与之并存？搭载 Flutter UI 框架的 Fuchsia 系统能否在 IOT 领域以及新的交互方式大放异彩，再领风骚？是否有万物互联互通的超级平台出现？</p>
<p>技术在不断演变中螺旋前进，平台自身也随之演进，未来 Flutter 会朝着多端一体化的方向发展，能支持更多的端（包括平板、笔记本、智能设备等）。作为一套跨平台的 UI 框架，Flutter 采用自渲染的技术方案，是一个上限很高的跨平台技术，但 Flutter 更重要的是需要提升工程化能力以及生态圈的建设，才能吸引更多的开发者加入。</p>
<h2 id="加入我们"><a href="#加入我们" class="headerlink" title="加入我们"></a>加入我们</h2><p>欢迎更多小伙伴加入字节跳动移动平台部，探索和深耕移动端技术，团队技术氛围浓厚，和我们开创可能成为不一样的未来，Android/iOS/Flutter等在北上深杭招聘各级别岗位，可简历发送至<a href="mailto:yuanhuihui@bytedance.com">yuanhuihui@bytedance.com</a>, 详细内推岗位见 <a href="http://gityuan.com/job。" target="_blank" rel="noopener">http://gityuan.com/job。</a></p>
]]></content>
  </entry>
  <entry>
    <title>【转载】Flutter 跨平台演进及架构开篇</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Flutter%20%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%94%E8%BF%9B%E5%8F%8A%E6%9E%B6%E6%9E%84%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p><strong>版权声明：</strong> 本站所有博文内容均为原创，转载请务必注明作者与原文链接，且不得篡改原文内容。</p>
</blockquote>
<h2 id="一、移动跨平台技术演进"><a href="#一、移动跨平台技术演进" class="headerlink" title="一、移动跨平台技术演进"></a>一、移动跨平台技术演进</h2><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h4><p>移动互联网发展十余年，伴随着 Android、iOS 等智能手机的不断普及，移动端已逐步取代 PC 端，成为兵家必争之地。正所谓“得移动端者得天下”，移动端已成为互联网领域最大的流量分发入口，一大批互联网公司正是在这大趋势下崛起。</p>
<h4 id="2-为什么需要跨平台技术"><a href="#2-为什么需要跨平台技术" class="headerlink" title="2. 为什么需要跨平台技术"></a>2. 为什么需要跨平台技术</h4><p>伴随着移动互联网的高速发展，公司间竞争越来越激烈，如何将好想法快速落地、快速试错，成为备受关注的问题。提升研发效率、缩短研发周期，保障产品快速试错并能快速迭代新功能，让新产品新功能以最快的速度同时抵达 Android、iOS 等多端用户。</p>
<p>众所周知，Android 应用采用 Java 或 Kotlin 编写，iOS 应用采用 Objective-C 或 Swift 编写，Web 端采用 HTML /CSS/JavaScript 编写。当需要开发支持多端的应用，每一端都需要独立研发、测试，一直到上线，以及后续的维护工作，工作量成倍增涨，势必延长研发周期。</p>
<p>为了解决多端独立开发的问题，跨平台技术便应运而生，各大互联网公司为此都投入大量人力，于是出现了各种跨平台技术框架，<strong>面对移动领域的跨平台技术方案的层出不穷，又该如何做技术选型呢？</strong></p>
<h4 id="3-移动端技术选型"><a href="#3-移动端技术选型" class="headerlink" title="3. 移动端技术选型"></a>3. 移动端技术选型</h4><p>作为移动端的跨端技术方案，所关注无外乎以下这4个方面：研发效率、动态性、多端一致性、性能体验。</p>
<p><img src="http://gityuan.com/img/flutter-arch/1.png" alt="img"></p>
<ol>
<li>研发效率：最大化代码复用，减少多端差异的适配工作量，降低开发成本，专注业务开发，实现“write once，run everywhere”的终极目标。效率提升是贯穿整个业务的生命周期线，即便业务上线后，可持续降低后续的维护成本，加快新feature的迭代速度，这是一个持续的效率收益。当然，这里不得不说，任何一门新技术在开发启动学习阶段会有一些成本，但上手后的收益是长期的。</li>
<li>动态化：突破渠道的更新频率，可快速迭代新功能，这一点不仅是跨平台技术的诉求，也是Native技术必备的杀手锏，这也是评估跨端技术的一个重要考核点。</li>
<li>多端一致性：好产品在多端UI设计上，往往是整体风格统一，所以业务方采用原生各自独立开发完成后，还需额外花不少时间来修改UI以保证多端一致性；可见，各端独立实现开发方式，带来的效率滞后，不仅仅是Android和iOS各开发一份代码的工作量，还有双端UI的一致性对齐的工作。</li>
<li>性能体验：一般地，跨端技术方案拥有以上多重优势，但在性能方面比原生流畅更差些。牺牲部分体验换来效率提升，这一点也是情理之中，试想一下，跨平台技术方案同时兼得这4点，那么原生技术恐怕已退出历史舞台，早已是跨平台技术的天下，所以往往跨平台技术的性能优劣便成为核心指标。</li>
</ol>
<h4 id="4-跨平台技术划分"><a href="#4-跨平台技术划分" class="headerlink" title="4. 跨平台技术划分"></a>4. 跨平台技术划分</h4><p>对研发效率和体验的不断追逐，移动端的跨平台技术方框架层出不穷，然则天下武功众多，万变不离其宗，从其核心本质来划分，可大致分为以下三大类：</p>
<p><img src="http://gityuan.com/img/flutter-arch/2.png" alt="img"></p>
<ol>
<li>Web技术：主要依赖于WebView的技术，功能支持受限，性能体验很差，比如PhoneGap、Cordova、小程序。</li>
<li>原生渲染：使用JavaScript作为编程语言，通过中间层转化为原生控件来渲染UI界面，比如React Native、Weex。</li>
<li>自渲染技术：自行实现一套渲染框架，可通过调用skia等方式完成自渲染，而不依赖于原生控件，比如Flutter、Unity。</li>
</ol>
<h4 id="5-跨平台技术演进"><a href="#5-跨平台技术演进" class="headerlink" title="5. 跨平台技术演进"></a>5. 跨平台技术演进</h4><p>跨平台技术，一直以来是每一个有追求的开发者所追逐的梦想，同时也是守旧者的噩梦，跨平台的多端一体化方案势必颠覆现有的原生各端独立开发模式，接下来列举众多的跨平台技术中最为关键的几个技术方案的演进阶段。</p>
<p><img src="http://gityuan.com/img/flutter-arch/3.png" alt="img"></p>
<p>从上图可以看出，技术演进过程大致分以下三个阶段： 第一阶段，采用WebView技术绘制界面的Hybrid混合开发技术，通过JS Bridge 将系统部分能力暴露给 JS 调用，其缺点是性能较差，功能受限，扩展性差，不适合交互复杂的场景，比如Cordova。 第二阶段，针对WebView界面性能等问题，于是绘制交还原生渲染，仅仅通过JS调用原生控件，相比WebView技术性能体验更好，这是目前绝大部分跨平台框架的设计思路，比如React Native、Weex。另外，最近小程序也比较火，第一和第二阶段的融合，依然采用WebView作为渲染容器，通过限制Web技术栈的子集，规范化组件使用，并逐步引入原生控件代表WebView渲染，以提升性能。 第三阶段，虽然通过桥接技术使用原生控件解决了功能受限问题，提升性能体验，但相比原生体验差距还是比较大，以及处理平台差异性非常耗费人力。于是Flutter提出自带渲染引擎的解决方案，尽可能减少不同平台间的差异性, 同时媲美原生的高性能体验，因此业界对 Flutter有着极高的关注度。</p>
<p><strong>面对现有的如此多跨平台方案，为何当下最火的跨平台技术是Flutter，有哪些优势呢？</strong></p>
<p>RN、Weex均使用JavaScript作为编程语言，JavaScript作为前端开发语言，在跨平台开发中可谓大放异彩，利用web技术不仅能开发出网站，也可以开发手机端web应用和移动端应用程序，似有一统三界(Android、iOS、Web)的趋势，这就是大家常说的“大前端”时代。这些技术方案流畅度不太好，平台一致性较差，至今还没能大面积取代原生开发。</p>
<p>Flutter是以Dart语言编写，开发体验更接近客户端，从大家使用反馈来看也是如此，Flutter开发环境这一套的流程对于前端开发来说并不太友好。Flutter的定位同样是多端一体化，但是以客户端为首，先磨平Android和iOS双端开发体验，再逐步向Web端渗透，从Flutter规划的Roadmap也能看出，Flutter for web目前仍处于预览版，Flutter客户端方向都已经如火如荼上线了不少应用。</p>
<p>在此之前，大家常说“大前端”，对于Flutter技术，在笔者看来称之为“大移动端”更贴切，Flutter的UI框架优先支持客户端(Android/iOS)应用的同时，然后再适配Web端。移动互联网时代，不少公司都制定“移动优先”的战略，甚至只开发移动端，没有Web端。移动互联网的时代造就“大移动端”，Flutter作为一款能做到媲美原生的高性能跨平台技术方案，或许一统天下。</p>
<p>在跨平台技术领域，只要挑战在，技术就不会停滞，伴随着技术不断演进与革新，终将走向美好。</p>
<h4 id="6-Flutter技术优势"><a href="#6-Flutter技术优势" class="headerlink" title="6. Flutter技术优势"></a>6. Flutter技术优势</h4><p>Flutter是彻底的跨平台方案，既没有采用webView，也没有采用JS桥接原生控件，而是自行实现一套UI框架，在引擎底层通过Skia渲染到屏幕。对于UI之外所需要使用的移动设备自身提供的服务，比如相机、定位、屏幕触摸等，则采用Platform Channels跟原生系统通信的方式来实现。</p>
<p>对于Flutter优势，回到前面讲到移动端技术选型的4要素，研发效率、动态性、多端一致性、性能体验，分别对应下面这一组词语。</p>
<p><img src="http://gityuan.com/img/flutter-arch/4.png" alt="img"></p>
<ol>
<li>高效率：采用dart语言编写代码，虽然刚开始上手需要点时间，但熟练后效率比较高。一套代码适用多个平台(Android、iOS、Web)，以及高效的Hot Reload能快速辅助调试；</li>
<li>动态化：2017年3月苹果下发警告邮件，禁止JSPatch等 iOS App热更新方案，从此iOS动态化成为一个不宜公开讨论的话题。同样地，Flutter引擎在某一个官方版本对动态化做过一些尝试，但后续基于风险考虑移除，当然并没有阻碍大家对技术的探索，这里不方便展开讨论；</li>
<li>高一致性：实现UI像素级的控制，Flutter渲染引擎依靠跨平台Skia图形库来实现，仅依赖系统图形绘制相关的接口，比如未来Android会支持vulkan，iOS会支持metal，这些都是通过skia封装调用。可最大程度上保证不同平台的体验一致性，见下图所示。</li>
</ol>
<p><img src="http://gityuan.com/img/flutter-arch/5.png" alt="img"></p>
<ol>
<li>高性能：渲染性能优于现有的各种跨平台框架，可媲美原生性能的跨平台技术方案，Dart代码执行效率比JS高，通过AOT编译成平台原生代码，渲染采用自渲染skia方案，既不需要JS Bridge桥接，也不需要Art虚拟机参与。再从渲染原理来看看Flutter的高性能的底气在哪里。</li>
</ol>
<p><img src="http://gityuan.com/img/flutter-arch/6_flutter_compare.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>Android原生框架，通过调用Java Framework层，再调用到skia来渲染界面；</li>
<li>其他跨平台方案(如RN)，通过JSBridge中间层来将JS写的APP转换成相应的原生渲染逻辑，可见比Native代码增加了更多逻辑，性能逊色差于原生框架；</li>
<li>Flutter框架，APP通过调用Dart Framework层，再直接调用到skia来渲染界面，并没有经过原生Framework过程，可见其渲染性能并不会弱于Native技术，这是一个性能上限很高的跨平台技术。</li>
</ul>
<p>当然，不得不说目前的Flutter确实不够尽善尽美，会存在一些不够尽善尽美之处，比如生态不够健全，包体积问题，但其该方案的上限比较高，想象空间比较大，相信更多开发者参与进来，经过更多打磨，未来会做得更好。</p>
<h4 id="7-业界发展近况"><a href="#7-业界发展近况" class="headerlink" title="7. 业界发展近况"></a>7. 业界发展近况</h4><p>2017年5月Google I/O大会正式对外公布Flutter，到2018年12月发布Flutter1.0，引发全球大量的开发者和企业开始研究Flutter。StackOverflow 2019年的全球开发者文件调查中，Flutter被评选为最受开发者欢迎的框架之一，超过了TensorFlow和Node.js。</p>
<p><img src="http://gityuan.com/img/flutter-arch/7_flutter_rank.png" alt="img"></p>
<p>到目前，全球越来越多的公司已经在大家耳熟能详的知名APP中使用Flutter技术并落地，尤其国内知名互联网公司对Flutter投入度很大，社区也是非常活跃。</p>
<p><img src="http://gityuan.com/img/flutter-arch/8_flutter_company.png" alt="img"></p>
<h4 id="8-Flutter未来趋势"><a href="#8-Flutter未来趋势" class="headerlink" title="8. Flutter未来趋势"></a>8. Flutter未来趋势</h4><p>目前Flutter主要在移动端Android/iOS双端跨端，Flutter 的愿景是成为一个多端运行的 UI 框架，能够支持不仅仅是移动端，还包括Web、桌面、甚至嵌入式设备。在2019 Google I/O 开发者大会上推出的使用 Flutter 开发 Web 应用的框架，同年9月发布Flutter 1.9，并将Flutter web合入Flutter主仓库。</p>
<p><img src="http://gityuan.com/img/flutter-arch/9_flutter_multi_arch.png" alt="img"></p>
<p>从架构图看，Flutter采用同一个Dart Framework层来统一Flutter C++引擎和Web引擎，最终可以运行在Android，iOS，Browser上，从Flutter引擎代码不难看出Flutter也是支持Fuchsia操作系统。</p>
<p>Fuchsia是Google内部正在开发的一款新的操作系统，采用Flutter作为系统默认的UI框架，也就是说Flutter天然支持Fuchsia，这无疑让Flutter在众多的跨平台方案更有优势。</p>
<p>从Fuchsia技术架构来看，内核层zircon的基础LK是专为嵌入式应用中小型系统设计的内核，代码简洁，适合嵌入式设备和高性能设备，比如IOT、移动可穿戴设备等，目前这些领域还没有标准化级别的垄断者。以及在框架层中有着语音交互、云端以及智能化等模块，由此笔者揣测未来Fuchsia率先应用在音控等智能嵌入式设备。</p>
<p><img src="http://gityuan.com/img/flutter-arch/10_fuchsia.png" alt="img"></p>
<p>目前大家普遍比较看好的未来两个技术就是5G和IoT时代。对于5G的需求，很大程度上是因为移动互联网发展到“IoT时代”的阶段。这个发展阶段，全球上网设备的数量可能会达到500亿个。随着5G+IOT时代的到来，现在大家比较关注的Flutter包大小也同样不再是一个问题，或许Flutter技术的生命期比客户端更长，或许Fuchsia正在驰骋IOT疆场，你所掌握的Flutter技术栈可以无缝迁移，一次弯道超车的机会。</p>
<p>到此，介绍完跨平台技术演进以及Flutter的优势。看到这，相信你可能对Flutter技术有一定兴趣，为了能让大家快速了解Flutter内部原理而不枯燥，Gityuan通过一系列图来帮大家从整体架构来快速理解Flutter。</p>
<h2 id="二、Flutter引擎架构"><a href="#二、Flutter引擎架构" class="headerlink" title="二、Flutter引擎架构"></a>二、Flutter引擎架构</h2><h4 id="1-Flutter技术架构"><a href="#1-Flutter技术架构" class="headerlink" title="1. Flutter技术架构"></a>1. Flutter技术架构</h4><p>先来看看Flutter整体的技术架构，分为四层，从上之下依次是Dart APP，Dart Framework， C++ Engine，Platform。</p>
<p><img src="http://gityuan.com/img/flutter-arch/11_flutter_arch.png" alt="img"></p>
<p>Flutter架构最核心的便是Framework（框架）和Engine（引擎）：</p>
<ul>
<li>Flutter Framework层：用Dart编写，封装整个Flutter架构的核心功能，包括Widget、动画、绘制、手势等功能，有Material（Android风格UI）和Cupertino（iOS风格）的UI界面， 可构建Widget控件以及实现UI布局。</li>
<li>Flutter Engine层：用C++编写，用于高质量移动应用的轻量级运行时环境，实现了Flutter的核心库，包括Dart虚拟机、动画和图形、文字渲染、通信通道、事件通知、插件架构等。引擎渲染采用的是2D图形渲染库Skia，虚拟机采用的是面向对象语言Dart VM，并将它们托管到Flutter的嵌入层。shell实现了平台相关的代码，比如跟屏幕键盘IME和系统应用生命周期事件的交互。不同平台有不同的shell，比如Android和iOS的shell。</li>
</ul>
<h4 id="2-Flutter编译产物"><a href="#2-Flutter编译产物" class="headerlink" title="2. Flutter编译产物"></a>2. Flutter编译产物</h4><p>看完Flutter内部架构，或许你好奇，Flutter不用Android/iOS的本地语言技术开发，Dart编写完的代码如何让不同系统可以识别，最终编译后得到的产物是什么呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/12_flutter_artifact.png" alt="img"></p>
<p>Flutter产物分为Dart业务代码和Engine代码各自生成的产物，图中的Dart Code包含开发者编写的业务代码，Engine Code是引擎代码，如果并没有定制化引擎，则无需重新编译引擎代码。</p>
<p>一份Dart代码，可编译生成双端产物，实现跨平台的能力。经过编译工具处理后可生成双端产物，图中便是release模式的编译产物，Android产物是由vm、isolate各自的指令段和数据段以及flutter.jar组成的app.apk，iOS产物是由App.framework和Flutter.framework组成的Runner.app。</p>
<p>这个过程涉及frontend_server、gen_snapshot、xcrun、ninja编译工具。frontend_server前端编译器会进行词法分析、语法分析以及相关全局转换等工作，将dart代码转换为AST(抽象语法树)，并生成app.dill格式的dart kernel。gen_snapshot经过CHA、内联等一系列执行流的优化，根据中间代码生成优化后的FlowGraph对象，再转换为具体相应系统架构（arm/arm64等）的二进制指令。</p>
<h4 id="3-Flutter引擎启动"><a href="#3-Flutter引擎启动" class="headerlink" title="3. Flutter引擎启动"></a>3. Flutter引擎启动</h4><p>既然了解了Flutter的编译产物，那你或许又好奇，Flutter这台引擎如何发动的，怎么跟Native衔接呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/13_flutter_engine_startup.png" alt="img"></p>
<p>这里以Android为例，熟悉Android的开发者，应该都了解APP启动过程，会执行Application和Activity的onCreate()方法，FlutterApplication和FlutterActivity的onCreate()方法正是连接Native和Flutter的枢纽。</p>
<ul>
<li>FlutterApplication.java的onCreate过程主要完成初始化配置、加载引擎libflutter.so、注册JNI方法；</li>
<li>FlutterActivity.java的onCreate过程，通过FlutterJNI的AttachJNI()方法来初始化引擎Engine、Dart虚拟机、Isolate、taskRunner等对象。再经过层层处理最终调用main.dart中main()方法，执行runApp(Widget app)来处理整个Dart业务代码。</li>
</ul>
<p>Flutter引擎启动中会创建有4个TaskRunner以及创建虚拟机，分别来看看它们的工作原理。</p>
<h4 id="4-TaskRunner工作原理"><a href="#4-TaskRunner工作原理" class="headerlink" title="4. TaskRunner工作原理"></a>4. TaskRunner工作原理</h4><p>Flutter引擎启动过程，会创建UI/GPU/IO这3个线程，会为这些线程依次创建MessageLoop对象，启动后处于epoll_wait等待状态。对于Flutter的消息机制跟Android原生的消息机制有很多相似之处，都有消息(或者任务)、消息队列(或任务队列)以及Looper；有一点不同的是Android有一个Handler类，用于发送消息以及执行回调方法，相对应Flutter中有着相近功能的便是TaskRunner。</p>
<p><img src="http://gityuan.com/img/flutter-arch/14_task_loop.png" alt="img"></p>
<p>上图是从源码中提炼而来的任务处理流程，比官方流程图更容易理解一些复杂流程的时序问题，后续会专门讲解个中原由。Flutter的任务队列处理机制跟Android的消息队列处理相通，只不过Flutter分为Task和MicroTask两种类型，引擎和Dart虚拟机的事件以及Future都属于Task，Dart层执行scheduleMicrotask()所产生的属于Microtask。</p>
<p>每次Flutter引擎在消费任务时调用FlushTasks()方法，遍历整个延迟任务队列delayed_tasks_，将已到期的任务加入task队列，然后开始处理任务。</p>
<ul>
<li>Step 1: 检查task，当task队列不为空，先执行一个task；</li>
<li>Step 2: 检查microTask，当microTask不为空，则执行microTask；不断循环Step 2 直到microTask队列为空，再回到执行Step 1；</li>
</ul>
<p>可简单理解为先处理完所有的Microtask，然后再处理Task。因为scheduleMicrotask()方法的调用自身就处于一个Task，执行完当前的task，也就意味着马上执行该Microtask。</p>
<p>了解了其工作机制，再来看看这4个Task Runner的具体工作内容。</p>
<ul>
<li>Platform Task Runner：运行在Android或者iOS的主线程，尽管阻塞该线程并不会影响Flutter渲染管道，平台线程建议不要执行耗时操作；否则可能触发watchdog来结束该应用。比如Android、iOS都是使用平台线程来传递用户输入事件，一旦平台线程被阻塞则会引起手势事件丢失。</li>
<li>UI Task Runner: 运行在ui线程，比如1.ui，用于引擎执行root isolate中的所有Dart代码，执行渲染与处理Vsync信号，将widget转换生成Layer Tree。除了渲染之外，还有处理Native Plugins消息、Timers、Microtasks等工作；</li>
<li>GPU Task Runner：运行在gpu线程，比如1.gpu，用于将Layer Tree转换为具体GPU指令，执行设备GPU相关的skia调用，转换相应平台的绘制方式，比如OpenGL, vulkan, metal等。每一帧的绘制需要UI Runner和GPU Runner配合完成，任何一个环节延迟都可能导致掉帧；</li>
<li>IO Task Runner：运行在io线程，比如1.io，前3个Task Runner都不允许执行耗时操作，该Runner用于将图片从磁盘读取出来，解压转换为GPU可识别的格式后，再上传给GPU线程。为了能访问GPU，IO Runner跟GPU Runner的Context在同一个ShareGroup。比如ui.image通过异步调用让IO Runner来异步加载图片，该线程不能执行其他耗时操作，否则可能会影响图片加载的性能。</li>
</ul>
<h4 id="5-Dart虚拟机工作"><a href="#5-Dart虚拟机工作" class="headerlink" title="5. Dart虚拟机工作"></a>5. Dart虚拟机工作</h4><p>Flutter引擎启动会创建Dart虚拟机以及Root Isolate。DartVM自身也拥有自己的Isolate，完全由虚拟机自己管理的，Flutter引擎也无法直接访问。Dart的UI相关操作，是由Root Isolate通过Dart的C++调用，或者是发送消息通知的方式，将UI渲染相关的任务提交到UIRunner执行，这样就可以跟Flutter引擎相关模块进行交互。</p>
<p>何为Isolate，从字面上理解是“隔离”，isolate之间是逻辑隔离的。Isolate中的代码也是按顺序执行，因为Dart没有共享内存的并发，没有竞争的可能性，故不需要加锁，也没有死锁风险。对于Dart程序的并发则需要依赖多个isolate来实现。</p>
<p><img src="http://gityuan.com/img/flutter-arch/15_isolate_heap.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>isolate堆是运该isolate中代码分配的所有对象的GC管理的内存存储；</li>
<li>vm isolate是一个伪isolate，里面包含不可变对象，比如null，true，false；</li>
<li>isolate堆能引用vm isolate堆中的对象，但vm isolate不能引用isolate堆；</li>
<li>isolate彼此之间不能相互引用；</li>
<li>每个isolate都有一个执行dart代码的Mutator thread，一个处理虚拟机内部任务(比如GC, JIT等)的helper thread； 可见，isolate是拥有内存堆和控制线程，虚拟机中可以有很多isolate，但彼此之间内存不共享，无法直接访问，只能通过dart特有的Port端口通信；isolate除了拥有一个mutator控制线程，还有一些其他辅助线程，比如后台JIT编译线程、GC清理/并发标记线程；</li>
</ul>
<h4 id="6-Widget架构概览"><a href="#6-Widget架构概览" class="headerlink" title="6. Widget架构概览"></a>6. Widget架构概览</h4><p>Flutter引擎启动后执行Dart业务，是通过runApp(Widget app)方法，那Widget又是什么呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/16_widget_arch.png" alt="img"></p>
<p>Widget是所有Flutter应用程序的基石，Widget可以是一个按钮，一种字体或者颜色，一个布局属性等，在Flutter的UI世界可谓是“万物皆Widget”。常见的Widget子类为StatelessWidget(无状态)和StatefulWidget(有状态)；</p>
<ul>
<li>StatelessWidget：内部没有保存状态，UI界面创建后不会发生改变；</li>
<li>StatefulWidget：内部有保存状态，当状态发生改变，调用setState()方法会触发StatefulWidget的UI发生更新，对于自定义继承自StatefulWidget的子类，必须要重写createState()方法。</li>
</ul>
<p><strong>三棵树</strong></p>
<p><img src="http://gityuan.com/img/flutter-arch/17_three_tree.png" alt="img"></p>
<p>图解：</p>
<ul>
<li>Widget是为Element描述需要的配置， 负责创建Element，决定Element是否需要更新。Flutter Framework通过差分算法比对Widget树前后的变化，决定Element的State是否改变。当重建Widget树后并未发生改变， 则Element不会触发重绘，则就是Widget树的重建并不一定会触发Element树的重建。</li>
<li>Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget配置和RenderObject渲染。Element状态由Flutter Framework管理， 开发人员只需更改Widget即可。</li>
<li>RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小、位置、绘制等都由RenderObject完成。</li>
</ul>
<p>可见，开发者通过Widget配置，Framework通过比对Widget配置来更新Element，最后调度RenderObject Tree完成布局排列和绘制。</p>
<h4 id="7-渲染原理"><a href="#7-渲染原理" class="headerlink" title="7. 渲染原理"></a>7. 渲染原理</h4><p>Dart的UI采用Widget来实现，最终转换为RenderObject，那界面又是如何渲染的呢？</p>
<p><img src="http://gityuan.com/img/flutter-arch/18_gpu_pipeline.png" alt="img"></p>
<p>渲染过程，UI线程完成布局、绘制操作，生成Layer Tree；GPU线程执行合成并光栅化后交给GPU来处理，其中几个关键步骤：</p>
<ul>
<li>Animate: 遍历_transientCallbacks，执行动画回调方法；</li>
<li>Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope()</li>
<li>Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作；</li>
<li>Compositing bits: 更新具有脏合成位的任何渲染对象， 对应于flushCompositingBits()；</li>
<li>Paint: 将绘制命令记录到Layer， 对应于flushPaint()；</li>
<li>Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()；</li>
</ul>
<p>GPU线程通过skia向GPU硬件绘制一帧的数据，GPU将帧信息保存到FrameBuffer里面，然后视频控制器会根据VSync信号从FrameBuffer取帧数据传递给显示器，从而显示出最终的画面。</p>
<h4 id="8-Platform-Channels"><a href="#8-Platform-Channels" class="headerlink" title="8. Platform Channels"></a>8. Platform Channels</h4><p>Flutter框架提供了UI的控件支持，对于APP除了UI还有其他依赖于Native平台的支持，比如调用Camera的功能，该怎么办呢？为此，Flutter通过提供Platform Channel的功能，使得Dart代码具备与Native交互的能力。</p>
<p><img src="http://gityuan.com/img/flutter-arch/19_platform_channels.png" alt="img"></p>
<p>Platform Channel用于Flutter与Native之间的消息传递，整个过程的消息与响应是异步执行，不会阻塞用户界面。Flutter引擎框架已完成桥接的通道，这样开发者只需在Native层编写定制的Android/iOS代码，即可在Dart代码中直接调用，这也就是Flutter Plugin插件的一种形式。</p>
<h2 id="三、Flutter源码解读"><a href="#三、Flutter源码解读" class="headerlink" title="三、Flutter源码解读"></a>三、Flutter源码解读</h2><p>笔者(Gityuan)之前一直从事于Android操作系统底层研发工作，今年刚接触Flutter，Flutter作为一门全新的跨平台技术框架，不断深究会发现这是一个小型系统，涉及到的技术很广：</p>
<ul>
<li>编译技术如何将dart代码转换为AST(抽象语法树)，如何汇编转换为机器码，打包产物是什么？</li>
<li>Flutter这台引擎如何发动的，怎么跟Native原生系统衔接运行，如何识别产物并加载到内存？</li>
<li>引擎启动后，TaskRunner如何分发任务，跟原生系统消息机制有什么关系？</li>
<li>Dart虚拟机如何管理内存，跟isolate又有什么关系？</li>
<li>开发者编写的Widget控件如何渲染到屏幕上？</li>
<li>Flutter如何通过plugin支持移动设备提供的服务？</li>
</ul>
<p>这些疑问在前面都逐一简要解答，如果仅仅是用Flutter做业务开发，并不需要掌握这么深度技术，不过，知其然知其所以然，能让你游刃有余。</p>
<p>本文同步在我的公号<a href="https://mp.weixin.qq.com/s/UZQU-PWM5JEb3dYtZKT6Cw" target="_blank" rel="noopener">《跨平台技术演进及Flutter未来》</a>，另外为大家创建了Flutter微信交流群，想加入可添加Gityuan微信好友，备注flutter即可，如发现任何文章有问题欢迎大家直接跟我反馈。</p>
<h4 id="启动篇"><a href="#启动篇" class="headerlink" title="启动篇"></a>启动篇</h4><ul>
<li><a href="http://gityuan.com/2019/06/22/flutter_booting/" target="_blank" rel="noopener">深入理解Flutter引擎启动</a></li>
<li><a href="http://gityuan.com/2019/06/23/dart-vm/" target="_blank" rel="noopener">深入理解Dart虚拟机启动</a></li>
<li><a href="http://gityuan.com/2019/06/29/flutter_run_app/" target="_blank" rel="noopener">深入理解Flutter应用启动</a></li>
</ul>
<h4 id="通信篇"><a href="#通信篇" class="headerlink" title="通信篇"></a>通信篇</h4><ul>
<li><a href="http://gityuan.com/2019/07/20/flutter_message_loop/" target="_blank" rel="noopener">深入理解Flutter消息机制</a></li>
<li><a href="http://gityuan.com/2019/08/10/flutter_channel/" target="_blank" rel="noopener">深入理解Flutter的Platform Channel机制</a></li>
<li><a href="http://gityuan.com/2019/07/21/flutter_future/" target="_blank" rel="noopener">深入理解Flutter异步Future机制</a></li>
<li><a href="http://gityuan.com/2019/07/27/flutter-isolate/" target="_blank" rel="noopener">深入理解Flutter的Isolate创建过程</a></li>
</ul>
<h4 id="渲染篇"><a href="#渲染篇" class="headerlink" title="渲染篇"></a>渲染篇</h4><ul>
<li><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="noopener">Flutter渲染机制—UI线程</a></li>
<li><a href="http://gityuan.com/2019/06/16/flutter_gpu_draw/" target="_blank" rel="noopener">Flutter渲染机制—GPU线程</a></li>
<li><a href="http://gityuan.com/2019/07/06/flutter_set_state/" target="_blank" rel="noopener">深入理解setState更新机制</a></li>
<li><a href="http://gityuan.com/2019/07/13/flutter_animator/" target="_blank" rel="noopener">深入理解Flutter动画原理</a></li>
</ul>
<p>后续笔者将持续研究与梳理Flutter内部机制的文章。</p>
<h2 id="四、结束语"><a href="#四、结束语" class="headerlink" title="四、结束语"></a>四、结束语</h2><p>本文分为三部分全方位逐级深入的分析Flutter技术，先讲述跨平台技术的过去与未来，再解读Flutter架构设计原理，最后剖析Flutter内部源码，后续将持续更新更多剖析技术深度细节以及实战经验，以彻底揭秘更多Flutter技术。</p>
<p>科技不断在进步，技术不断发展，移动跨平台技术几乎从Android、iOS诞生不久便出现，已发展快10年。时至今日，兼具跨端高效率与高性能体验的Flutter力压群雄，崭露头角，已然成为当下最热门的移动端新技术，全球越来越多的公司在Flutter技术布局并落地产品应用，社区也非常活跃。</p>
<p>随着5G+IOT时代的到来，Fuchsia系统或许发力IOT新战场，你所掌握的Flutter技术栈可以无缝迁移，这是一次弯道超车的机会。即便Fuchsia落败，相信只要深扎Flutter系统技术的精髓，其他任何的移动端新技术都可以轻松快速地掌握。</p>
<p>最后，用一句话来结束本次分享，“有时候，你选择一个方向，不是因为它一定会成为未来，而是它有可能成为不一样的未来。”</p>
]]></content>
  </entry>
  <entry>
    <title>一篇文章搞定 macOS 截图</title>
    <url>/2020/04/23/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E5%AE%9A%20macOS%20%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<hr>
<blockquote>
<p><strong>版权声明：</strong> <em>本文所有内容均为 @EchoForger 的个人博客 <a href="https://www.wildptr.cn">WildPtr 野指针</a>的原创内容，转载请务必注明作者与原文链接，且不得篡改原文内容。</em></p>
</blockquote>
<p>截图是我们在日常办公中十分常用的操作之一，很多人在刚刚接触 macOS 的时候，对新系统的截图功能非常陌生，今天就让我们用一篇文章，解决在 macOS 上的截图需求。</p>
<h2 id="普通系统截图"><a href="#普通系统截图" class="headerlink" title="普通系统截图"></a>普通系统截图</h2><p>系统截图是最方便也最常用的截图方法，不需要安装任何插件，操作也非常简单，可以使用以下快捷键进行截图。</p>
<h3 id="Command-Shift-3-截取整个屏幕"><a href="#Command-Shift-3-截取整个屏幕" class="headerlink" title="Command + Shift + 3 截取整个屏幕"></a><strong><code>Command + Shift + 3</code> 截取整个屏幕</strong></h3><p>使用此快捷键会截取屏幕的所有内容，生成一张与屏幕像素尺寸相同的图片。屏幕像素尺寸可以在“关于本机”&gt;“显示器”中看到。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS05NDFmNzc0OWI5NTM3MGZkLnBuZw?x-oss-process=image/format,png" alt="查看屏幕像素尺寸" style="zoom:50%;" />


<h3 id="Command-Shift-4-截取部分屏幕"><a href="#Command-Shift-4-截取部分屏幕" class="headerlink" title="Command + Shift + 4 截取部分屏幕"></a><strong><code>Command + Shift + 4</code> 截取部分屏幕</strong></h3><p>选取需要截图的区域后，按住鼠标的同时按下 <code>空格</code>，这时你能通过移动鼠标来移动整个已选择区域；按住鼠标的同时按下 <code>Shift</code> 键，这时你能通过横向或竖向移动鼠标来改变已选择区域的长或高；按住鼠标的同时按下 <code>Option</code> 键，这时你通过移动鼠标可以对称地改变截图区域。</p>
<p>按下<code>Command + Shift + 4 + 空格</code> 再点击某个窗口可以截取选中的窗口，点击桌面可以截取桌面壁纸。</p>
<p>截取窗口时，macOS 默认会给截图加上一层<strong>软阴影</strong>，个人认为这层软阴影还是挺好看的，如果你想去除，只需要在截图的时候按住 <code>Option</code> 即可。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS04YmE5ZTFiMzBkN2EyODZjLnBuZw?x-oss-process=image/format,png" alt="有阴影截图（左）和无阴影截图（右）"></p>
<p>也可以在终端执行一条命令永久去除软阴影：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.screencapture disable-shadow -bool true&amp;&amp;killall SystemUIServer</span><br></pre></td></tr></table></figure>

<p>如果要把软阴影找回来，同样也只需要一条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.screencapture disable-shadow -bool false&amp;&amp;killall SystemUIServer</span><br></pre></td></tr></table></figure>

<p>如果你使用的是带触控栏的 MacBook Pro，则在按下 <code>Command + Shift + 4</code> 后可以在触控栏选择“截取整个屏幕”、“截取所选窗口”或“截取部分屏幕”，也可以对截图的储存位置进行修改。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1kMTc3ZDJlN2M3ZmFlZDQwLnBuZw?x-oss-process=image/format,png" alt="使用触控栏进行截图操作"></p>
<h3 id="Command-Shift-5-打开截图工具栏"><a href="#Command-Shift-5-打开截图工具栏" class="headerlink" title="Command + Shift + 5 打开截图工具栏"></a><strong><code>Command + Shift + 5</code> 打开截图工具栏</strong></h3><h3 id="Command-Shift-6-截取触控栏"><a href="#Command-Shift-6-截取触控栏" class="headerlink" title="Command + Shift + 6 截取触控栏"></a><strong><code>Command + Shift + 6</code> 截取触控栏</strong></h3><p>如果你在上述任意一套组合键中加上 <code>Control</code>，则截图会自动进入系统的剪切板记录，桌面不会再保存截图，此时你可以直接使用 <code>Command + V</code> 进行粘贴。</p>
<p>当你按下截图组合键后想停止截图操作，只要按 <code>Esc</code> 就能停止截图，此时不会保存任何图片文件。</p>
<p>当然，以上的快捷键都可以根据个人喜好进行修改。若要修改截图快捷键只需要进入“系统偏好设置”&gt;”键盘”&gt;“快捷键”&gt;“截图”进行修改即可。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS0yZTcwOTBmYTE0ZjJiNjdiLnBuZw?x-oss-process=image/format,png" alt="修改快捷键" style="zoom:50%;" />


<h3 id="系统自带的“截屏”app"><a href="#系统自带的“截屏”app" class="headerlink" title="系统自带的“截屏”app"></a>系统自带的“截屏”app</h3><p>在 macOS 中有自在的截图 app“截屏”，它就藏在程序列表的“其他”文件夹中，打开“截屏”app 就相当于启动截图工具栏，与 <code>Command + Shift + 5</code> 效果相同。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS04YWY2NmI4NDIxNzgxYWZlLnBuZw?x-oss-process=image/format,png" alt="截屏"></p>
<h3 id="截图缩略图"><a href="#截图缩略图" class="headerlink" title="截图缩略图"></a>截图缩略图</h3><p>在使用系统截图截图完成后，便会在屏幕的右下角生成一个截图缩略图，我们可以点击它，对截图进行快速编辑。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1kZWEwZTgzZWVhMTA0MzJlLnBuZw?x-oss-process=image/format,png" alt="对截图进行快速编辑"></p>
<p>如果不想处理，可以将其向右轻扫。我们还可以拖动缩略图储存到不同的位置。不仅如此，还可以按住 <code>Control</code> 并点击或者右击缩略图，弹出菜单选项，选择不同的处理方式。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1hZmNlNzQ2OWFhMjkxOGZhLnBuZw?x-oss-process=image/format,png" alt="菜单选项" style="zoom:67%;" />


<p>可以说，macOS 自带的截图功能已经非常强大，足以满足我们日常生活中的绝大多数需求，但接下来要说的截图工具，会让你的 Mac 截图更强大。</p>
<h2 id="长截图"><a href="#长截图" class="headerlink" title="长截图"></a>长截图</h2><p>说到 macOS 的长截图，在这里就不得不提 iShot 了。iShot 是一款非常优秀的截图软件，我们可以在 <a href="https://apps.apple.com/cn/app/ishot-%E6%88%AA%E5%9B%BE-%E9%95%BF%E6%88%AA%E5%9B%BE-%E8%B4%B4%E5%9B%BE-%E5%BD%95%E5%B1%8F%E5%B7%A5%E5%85%B7/id1485844094?mt=12" target="_blank" rel="noopener">Mac App Store 上免费下载</a>。安装完成后，屏幕右上角会出现一个小按钮，我们只需要点击它就可以使用各种截图功能。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS0yZWExZjU2NzI4NTQxZDYyLnBuZw?x-oss-process=image/format,png" alt="屏幕右上角会出现一个小按钮" style="zoom:50%;" /></p>
<p>想要使用 iShot 的长截图功能，只需要点击截图（快捷键 <code>Option + A</code>），然后框选出要截图的窗口，点击下方的“长截图”按钮（或者直接使用快捷键 <code>S</code>）即可开始长截图。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1iZWQ0ODAyMDc1ZmM1M2RlLmdpZg" alt="使用 iShot 进行长截图.gif"></p>
<p>进行长截图时，缓慢的滑动页面，完成后点击下方的确认，一张精美的长截图便制作完成了。</p>
<h2 id="截取动图"><a href="#截取动图" class="headerlink" title="截取动图"></a>截取动图</h2><p>除了静态的截图，iShot 也是一款优秀的动图截取软件，可以轻松利用 iShot 制作精美动图，为你的文章增添色彩。</p>
<p>截取 gif 动图，只需要点击右上角的 iShot 小图标，点击“开始录屏”（快捷键 <code>Option + W</code>）并框选住要录制的区域。在下方的工具栏中可以选择画质，记得在选项中选择格式为“gif”，这样才会录制动图而不是视频哦。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1iMDdlZDAyZjJhMzgwYTJiLnBuZw?x-oss-process=image/format,png" alt="选择格式为 gif" style="zoom:50%;" />


<p>当然这里 gif 不要选择过高的清晰度，因为这样会导致 gif 文件的体积非常大，以至于不适合在网络上传输。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于 macOS 的截图方法就介绍到这里，不得不说 macOS 的截图功能相对于隔壁的 Windows 真的是强大了不少，掌握了这些截图的方法，便可以很大程度上地提升工作和学习的效率 ，省去很多不必要的麻烦了。</p>
]]></content>
      <categories>
        <category>数字生活</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Hexo 和 GitHub 搭建自己的个人博客平台</title>
    <url>/2020/04/23/%E4%BD%BF%E7%94%A8%20Hexo%20%E5%92%8C%20GitHub%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<hr>
<blockquote>
<p><strong>版权声明：</strong> <em>本文所有内容均为 @EchoForger 的个人博客 <a href="https://www.wildptr.cn">WildPtr 野指针</a>的原创内容，转载请务必注明作者与原文链接，且不得篡改原文内容。</em></p>
</blockquote>
<p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> 是一个高效、简洁的博客框架，我们可以使用其丰富的插件和主题快速地搭建属于自己的博客平台。<a href="https://github.com" target="_blank" rel="noopener">GitHub</a> 则作为代码仓库在云端托管所搭建的网站，尽管 GitHub 在国内的速度有点不尽人意，但是作为个人博客的载体还是绰绰有余。接下来就让我手把手地教各位在 macOS 环境下使用 Hexo 和 GitHub 搭建自己的个人博客平台。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>前往 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js 官网</a>安装 Node.js (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)。</p>
<h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>如果安装了 <a href="https://developer.apple.com/xcode/" target="_blank" rel="noopener">Xcode</a> 则可以跳过此步骤，因为苹果在 XCode 中携带了 Git 的二进制包。</p>
<p>通过 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 安装 Git，先安装 Homebrew。打开“终端”，并执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install.sh)&quot;</span><br></pre></td></tr></table></figure>

<p>安装 Git。终端执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install git</span><br></pre></td></tr></table></figure>

<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。“终端”执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><h3 id="创建网站文件夹"><a href="#创建网站文件夹" class="headerlink" title="创建网站文件夹"></a>创建网站文件夹</h3><p>新建一个空的文件夹，“终端”执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p><code>&lt;folder&gt;</code> 是新建文件夹的路径，可以将文件夹拖至“终端”窗口中，将自动输入文件夹路径。</p>
<p>命令执行完成后，文件夹的结构如下图所示。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1jODFhMmVlNzU4ZjY2NjdhLnBuZw?x-oss-process=image/format,png" alt="文件夹的结构" style="zoom:67%;" />


<h3 id="选取主题"><a href="#选取主题" class="headerlink" title="选取主题"></a>选取主题</h3><p>前往 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo 官网的主题页面</a>选择主题，点击主题名称可以前往该主题的源码仓库。<img src="https://upload-images.jianshu.io/upload_images/23107301-02da7e7e5a1d9f4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" Hexo 官网的主题页面
"></p>
<p>下载主题的源码，解压并放入网站文件夹中的 <code>theme</code> 子文件夹中。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS01ZDNhOWEwNjRiYzI3YzE2LnBuZw?x-oss-process=image/format,png" alt="下载主题的源码"></p>
<p>修改 <code>_config.yml</code> 中的 <code>theme</code> 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: &lt;theme folder name&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;theme folder name&gt;</code> 为主题的文件夹名称，例如：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS0zODQ0NjJlMDMwMTY0MmM1LnBuZw?x-oss-process=image/format,png" alt="修改 _config.yml 中的 theme 值" style="zoom:67%;" />


<p>这样便成功地修改了博客的主题。</p>
<h3 id="配置网站"><a href="#配置网站" class="headerlink" title="配置网站"></a>配置网站</h3><p>网站的配置信息储存在 <code>_config.yml</code>（注意这里的 <code>_config.yml</code> 是网站根目录下的）中，打开文件进行修改。这里只介绍几个简单的参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>title</code></td>
<td>网站标题</td>
</tr>
<tr>
<td><code>subtitle</code></td>
<td>网站副标题</td>
</tr>
<tr>
<td><code>author</code></td>
<td>您的名字</td>
</tr>
<tr>
<td><code>theme</code></td>
<td>主题文件夹名称</td>
</tr>
<tr>
<td><code>deploy</code></td>
<td>部署信息</td>
</tr>
</tbody></table>
<h2 id="部署至-GitHub"><a href="#部署至-GitHub" class="headerlink" title="部署至 GitHub"></a>部署至 GitHub</h2><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>首先，需要在 GitHub 上<a href="https://github.com/join" target="_blank" rel="noopener">创建一个账户</a>。</p>
<p>在 GitHub 上创建一个 <code>repository</code></p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS01YjU5MzViYmI2OGQ5YWYzLnBuZw?x-oss-process=image/format,png" alt="创建一个 repository" style="zoom:50%;" />


<p>其命名方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username.github.io</span><br></pre></td></tr></table></figure>

<p>其中 <code>username</code> 为 GitHub 用户名。</p>
<h3 id="配置网站-1"><a href="#配置网站-1" class="headerlink" title="配置网站"></a>配置网站</h3><p>修改 <code>_config.yml</code> 中的 <code>deploy</code> 值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: &lt;repo address&gt;</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p><code>&lt;repo address&gt;</code>  为新建仓库的地址。例如：<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS0zYThlZGZiNTg3ZjNkNDNjLnBuZw?x-oss-process=image/format,png" alt="修改 _config.yml 中的 deploy 值"></p>
<h3 id="安装-Deployer-Git"><a href="#安装-Deployer-Git" class="headerlink" title="安装 Deployer Git"></a>安装 Deployer Git</h3><p>“终端”执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>“终端”执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>第一行语句用来生成网页静态文件，第二行语句将网页内容上传至 GitHub 仓库。</p>
<p>过程中需要输入 GitHub 的用户名的密码。当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p>
<p>部署完成后，便可以通过 <code>username.github.io</code> 访问新搭建的博客了！</p>
<h3 id="更新网站内容"><a href="#更新网站内容" class="headerlink" title="更新网站内容"></a>更新网站内容</h3><p>若在本地对网站进行了更改，需要对云端托管的代码进行更新，应该先生成网页的静态文件，然后将其部署至云端。“终端”执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>与 Apple Music 一同优雅地享受音乐</title>
    <url>/2020/04/23/%E4%B8%8E%20Apple%20Music%20%E4%B8%80%E5%90%8C%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BA%AB%E5%8F%97%E9%9F%B3%E4%B9%90/</url>
    <content><![CDATA[<hr>
<blockquote>
<p><strong>版权声明：</strong> <em>本文所有内容均为 @EchoForger 的个人博客 <a href="https://www.wildptr.cn">WildPtr 野指针</a>的原创内容，转载请务必注明作者与原文链接，且不得篡改原文内容。</em></p>
</blockquote>
<p>还在使用网易云音乐、QQ音乐又或是其他音乐流媒体平台吗？相信在这个版权之战打得热火朝天的时代，我们往往需要同时使用多个音乐软件，甚至开通多项音乐服务，才能满足我们的听歌需求。为了听周杰伦得去QQ音乐充音乐包，为了听华晨宇得去网易云购买专辑，总之各大音乐平台都掌握着某些歌手的独家的版权。不仅如此，除了这些，你还得忍受各种各样的广告推送、音乐订阅号、音乐短视频……这些和音乐无关的东西渐渐让我们远离了音乐本身。</p>
<blockquote>
<p>你有多久没有认真地听一首歌了。</p>
</blockquote>
<p>而 Apple Music 却是一个优雅的存在，它是一个音乐软件，它也只是一个音乐软件；它让我们可以听歌，也仅仅可以听歌。很多人往往因为对过去 iTunes 难以操作的观点，对 Apple Music 的软件界面望而却步，抱怨苹果为什么会开发出这么难用的软件。其实不然，Apple Music 是我用过最好的音乐库管理软件，它在做到优雅简洁的同时又不乏强大的管理功能。接下来就让我们一起打造属于自己的音乐资料库。</p>
<h2 id="建立云端音乐资料库"><a href="#建立云端音乐资料库" class="headerlink" title="建立云端音乐资料库"></a>建立云端音乐资料库</h2><p>使用 Apple Music 的第一步就是打开其云端资料库。这里需要订阅 Apple Music 的音乐服务，在国内的资费是 10 元每个月，或者以学生优惠 5 元每个月的价格订阅即可，然后在各个设备上登陆你的 Apple ID，并在“设置”或者“偏好设置”中打w开“同步资料库”。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1lNzA5YzZiMzIzYWRhMGM0LnBuZw?x-oss-process=image/format,png" alt="打开其云端资料库"></p>
<h2 id="添加音乐"><a href="#添加音乐" class="headerlink" title="添加音乐"></a>添加音乐</h2><p>添加音乐的方式有很多种，你可以通过 Apple Music 在线音乐库或者从其他音乐软件添加音乐，接下来将逐一介绍。</p>
<h3 id="通过-Apple-Music-在线音乐库添加音乐"><a href="#通过-Apple-Music-在线音乐库添加音乐" class="headerlink" title="通过 Apple Music 在线音乐库添加音乐"></a>通过 Apple Music 在线音乐库添加音乐</h3><p>当然这是最简单也最方便的音乐添加方式，只需要在 Apple Music 的在线音乐库中搜索然后添加即可。这样添加固然很好，所有的歌曲信息以及歌词、专辑封面等都会自动匹配好。关键是在 iOS 13 以及 macOS 10.15.4 及以后的 Apple Music 中还有非常炫酷的动态歌词，歌词根据音乐律动，不得不说苹果的动态歌词真的做的非常出色，也引来了其他音乐平台的模仿。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1jNzQ0OGQ3NWMzNzliM2ZiLlBORw?x-oss-process=image/format,png" alt="苹果的动态歌词"></p>
<h3 id="通过其他音乐软件添加音乐"><a href="#通过其他音乐软件添加音乐" class="headerlink" title="通过其他音乐软件添加音乐"></a>通过其他音乐软件添加音乐</h3><p>然而 Apple Music 对于喜欢华语音乐的人来说其曲库算不上丰富，很多中国的独立音乐人在 Apple Music 上都搜不到，甚至有些歌手的专辑收录不全（其实其他的流媒体音乐平台也有很多音乐没有版权），在这种情况下，我们便可以手动地从其他软件下载音乐文件，并添加到 Apple Music 资料库中。</p>
<p>不过由于我国很多音乐软件下载下来的音乐都是播放器独家的格式，没有办法在其他播放器中播放（例如网易云音乐的 .ncm 格式），要想获取 .mp3 格式的音乐文件，就得花钱购买专辑，把这些专辑购买下来也未尝不可，但我相信下面的两个网站可以帮到你。</p>
<blockquote>
<p>.ncm 格式在线转换为 .mp3 格式：<a href="http://ncm.worthsee.com" target="_blank" rel="noopener">http://ncm.worthsee.com</a></p>
<p>.qmc 格式在线转换为 .mp3 格式：<a href="http://convert.freelrc.com/QMC-to-MP3" target="_blank" rel="noopener">http://convert.freelrc.com/QMC-to-MP3</a></p>
</blockquote>
<p>得到 .mp3 格式的音乐文件后，只需要在 macOS 端的 Apple Music 上，将音乐文件拖到“歌曲列表”中，就会自动添加到云端音乐库中。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1iZWYwZjc0MDRhMzdmYzI0LnBuZw?x-oss-process=image/format,png" alt="更新云端资料库"></p>
<p>若没有添加成功，我们可以通过“文件”&gt;“资料库”&gt;“更新云端资料库”来进行同步。</p>
<p>同步的过程中，Apple Music 会将本地的音乐与 Apple Music 在线资料库中的音乐进行匹配（妙选），若没有匹配到相同的音乐，将会自动上传本地音乐文件。</p>
<p>但是这个上传的网络速度在国内貌似并不很好，上传的时间也根据网络速度而定。</p>
<h2 id="整理音乐资料库"><a href="#整理音乐资料库" class="headerlink" title="整理音乐资料库"></a>整理音乐资料库</h2><p>当你将自己的音乐都添加到 Apple Music 云端资料库之后，一个属于自己的私人音乐资料库便构建完成了，从此再也不要打开多个软件进行听歌了，只需要点击 Apple Music 应用图标，所有的音乐便全部掌握在手中，而且不要担心歌曲版权下架（Apple Music 在线资料库也存在音乐版权下架），属于自己的音乐永远在自己的资料库中。</p>
<p>而接下来就应该对自己的音乐库进行整理，特别是对通过其他音乐软件添加的音乐进行整理。因为往往从网上下载的音乐，其歌曲信息极有可能不完整，比如缺少专辑图片、缺少专辑发行年份等等。作为一个轻微强迫症患者，我不允许我的资料库出现这种混乱的现象，所以需要对资料库的信息进行整理，而 Apple Music 在这方面做的非常的出色。</p>
<h3 id="更改歌曲信息"><a href="#更改歌曲信息" class="headerlink" title="更改歌曲信息"></a>更改歌曲信息</h3><p>在歌曲列表中可以自定义显示的歌曲参数，如“专辑艺人”、“类型”、“年份”等，我们可以直接在歌曲列表中对这些信息进行编辑。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS05OTQzODc2NGY0ODhkZDQxLnBuZw?x-oss-process=image/format,png" alt="自定义显示的歌曲参数"></p>
<p>选择某个音乐右击“显示简介”或者 <code>Command + I</code> 可以查看具体某一个音乐的信息，还可以对音乐的插图、歌词进行修改。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS01YmIxNTNmZTljYzE4NTRlLnBuZw?x-oss-process=image/format,png" alt="显示简介" style="zoom:50%;" />


<p>Apple Music 的强大之处便是在此，可以非常直观地对资料库中所有的歌曲信息进行修改。</p>
<h3 id="创建智能播放列表"><a href="#创建智能播放列表" class="headerlink" title="创建智能播放列表"></a>创建智能播放列表</h3><p>当歌曲的信息都被正确地写入之后，我们便可以按照自己的意愿随意地欣赏资料库中的音乐。例如我们可以按照流派、年代以及歌曲情绪来听歌。而这一切都得益于 Apple Music 的智能播放列表。<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS04NDAyZDAxNzVlNTRjMGI1LnBuZw?x-oss-process=image/format,png" alt="创建智能播放列表"></p>
<p>点击“文件”&gt;“新建智能播放列表”，弹出条件筛选对话框。例如我想收听 21 世纪 00 年代的华语音乐，我可以设置为“年份在 2000 至 2010 范围内”且“类型是国语流行”的音乐，点击确定，你资料库中符合条件的音乐就自动组成了一个播放列表。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS1jY2IyNmRkYWVjMjExYTcxLnBuZw?x-oss-process=image/format,png" alt="条件筛选对话框" style="zoom:67%;" />


<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMzEwNzMwMS05YjMzZTgyODJiZmFlYWU0LnBuZw?x-oss-process=image/format,png" alt="自动组成了一个播放列表"></p>
<p>不仅如此，我们在听音乐时可以对歌曲标记星级来代表我们对歌曲的喜爱程度，这样在建立智能播放列表的时候就可以根据自己的喜爱程度建立。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整理好自己的音乐资料库确实不是一件简单的事情，我们需要投入我们的时间与精力，而正是我们对于这种对音乐认真与执着，本着生命在于折腾的观念，让我们在挑选每一首歌的时候都非常的慎重。摆脱了流媒体音乐的各种推送和广告之后，我的音乐软件变成了一个单纯的音乐载体，它更像是一本回忆录，每听到每一首歌的时候，都可以想起第一次听到这首歌时的场景。这样纯粹的音乐播放器虽然“减”去了很多东西，但却“增”加了我对于音乐本身的理解与感悟。戴上耳机，尽情享受音乐最纯粹的乐趣吧！</p>
]]></content>
      <categories>
        <category>数字生活</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】理解Android P内部API的限制调用机制</title>
    <url>/2020/04/23/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E7%90%86%E8%A7%A3Android%20P%E5%86%85%E9%83%A8API%E7%9A%84%E9%99%90%E5%88%B6%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>本文基于原生Android 9.0源码来解读hidden API的限制调用机制</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">libcore/ojluni/src/main/java/java/lang/Class.java</span><br><span class="line">art/runtime/<span class="keyword">native</span>/java_lang_Class.cc</span><br><span class="line">art/runtime/hidden_api.h</span><br><span class="line">art/runtime/runtime.h</span><br></pre></td></tr></table></figure>

<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>每一次Android大版本的升级，往往会有大量的APP出现兼容性问题，导致这个情况的主要原因是由于APP的热修复SDKs以及依赖Android internal API(内部API)，也就是非SDK API。这些API是指标记@hide的类、方法以及字段，它们不属于官方Android SDK的字段与函数。</p>
<p>Google希望未来Android大版本升级，APP都能正常运行，而很多APP对内部API的调用通过反射或JNI间接调用的方法来调用，破坏兼容性。 为此Google从Android P开始限制对内部API的使用，继续使用则抛出如下异常。</p>
<p><img src="http://gityuan.com/images/hidden-api/hidden-api-exp.png" alt="hidden-api-exp"></p>
<p>虽然Google目前对这个限制使用不是很完善，存在一些漏洞，可能有些APP会利用漏洞继续使用，但这是不推荐的方式，标记@hide的类、方法以及字段在跨版本之间的兼容性将会无法保障，如果继续使用，那么后续出现兼容性问题将不再另行通知。因此，建议APP减少使用非SDK接口以提升稳定性。开发者都是按Google的预期使用公平的SDK或者NDK，对于开发者便于维护，对于用户体验更一致，大大有利于Android生态的健康发展。</p>
<p>Android 7.0对Native的NDK的调用限制是手铐，而Android 9.0对Java层SDK的调用限制就是脚铐，那么对于Android应用想再搞一些插件化之类的黑科技便是带着脚手铐跳舞，即便能跳但舞姿已不太优雅了。</p>
<h2 id="二、内部API限制"><a href="#二、内部API限制" class="headerlink" title="二、内部API限制"></a>二、内部API限制</h2><p>Android P限制APP对内部API的调用，而内部API只能通过反射或JNI间接调用，那么限制机制必然是在反射和JNI方法调用链中插入判断逻辑。 在下面小节2.4.2会讲述到所有的限制场景，这里以反射获取方法的getDeclaredMethod()为例来展开说明，其他反射或JNI调用也是类似的逻辑。</p>
<h3 id="2-1-getDeclaredMethod"><a href="#2-1-getDeclaredMethod" class="headerlink" title="2.1 getDeclaredMethod"></a>2.1 getDeclaredMethod</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMethod(name, parameterTypes, <span class="keyword">false</span>);  <span class="comment">//【见小节2.2】</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-getMethod"><a href="#2-2-getMethod" class="headerlink" title="2.2 getMethod"></a>2.2 getMethod</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;[] parameterTypes, <span class="keyword">boolean</span> recursivePublicMethods)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;  <span class="comment">//方法名不能为空</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameterTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parameterTypes = EmptyArray.CLASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : parameterTypes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;  <span class="comment">//参数不能为空</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(<span class="string">"parameter type is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非public方法，则执行getDeclaredMethodInternal【见小节2.3】</span></span><br><span class="line">    Method result = recursivePublicMethods ? getPublicMethodRecursive(name, parameterTypes)</span><br><span class="line">                                           : getDeclaredMethodInternal(name, parameterTypes);</span><br><span class="line">    <span class="comment">//找不到，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> ||</span><br><span class="line">        (recursivePublicMethods &amp;&amp; !Modifier.isPublic(result.getAccessFlags()))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodException(name + <span class="string">" "</span> + Arrays.toString(parameterTypes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-getDeclaredMethodInternal"><a href="#2-3-getDeclaredMethodInternal" class="headerlink" title="2.3 getDeclaredMethodInternal"></a>2.3 getDeclaredMethodInternal</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FastNative</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> Method <span class="title">getDeclaredMethodInternal</span><span class="params">(String name, Class&lt;?&gt;[] args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getDeclaredMethodInternal这是一个native方法，经过JNI调用，进入如下方法：</p>
<p>[-&gt; java_lang_Class.cc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">Class_getDeclaredMethodInternal</span><span class="params">(JNIEnv* env, jobject javaThis,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               jstring name, jobjectArray args)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopedFastNativeObjectAccess <span class="title">soa</span><span class="params">(env)</span></span>;</span><br><span class="line">  <span class="function">StackHandleScope&lt;1&gt; <span class="title">hs</span><span class="params">(soa.Self())</span></span>;</span><br><span class="line">  DCHECK_EQ(Runtime::Current()-&gt;GetClassLinker()-&gt;GetImagePointerSize(), kRuntimePointerSize);</span><br><span class="line">  DCHECK(!Runtime::Current()-&gt;IsActiveTransaction());</span><br><span class="line">  Handle&lt;mirror::Method&gt; result = hs.NewHandle(</span><br><span class="line">      mirror::Class::GetDeclaredMethodInternal&lt;kRuntimePointerSize, <span class="literal">false</span>&gt;(</span><br><span class="line">          soa.Self(),</span><br><span class="line">          DecodeClass(soa, javaThis),</span><br><span class="line">          soa.Decode&lt;mirror::String&gt;(name),</span><br><span class="line">          soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(args)));</span><br><span class="line">  <span class="comment">//检测该方法是否允许访问【小节2.4】</span></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="literal">nullptr</span> || ShouldBlockAccessToMember(result-&gt;GetArtMethod(), soa.Self())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> soa.AddLocalReference&lt;jobject&gt;(result.Get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-ShouldBlockAccessToMember"><a href="#2-4-ShouldBlockAccessToMember" class="headerlink" title="2.4 ShouldBlockAccessToMember"></a>2.4 ShouldBlockAccessToMember</h3><p>[-&gt; java_lang_Class.cc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ALWAYS_INLINE <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">ShouldBlockAccessToMember</span><span class="params">(T* member, Thread* self)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//【小节2.5】</span></span><br><span class="line">  hiddenapi::Action action = hiddenapi::GetMemberAction(</span><br><span class="line">      member, self, IsCallerTrusted, hiddenapi::kReflection);</span><br><span class="line">  <span class="comment">//对于不是允许级别的接口，则通知相应监听器</span></span><br><span class="line">  <span class="keyword">if</span> (action != hiddenapi::kAllow) &#123;</span><br><span class="line">    hiddenapi::NotifyHiddenApiListener(member);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> action == hiddenapi::kDeny;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是限制反射访问，此处的access_method等于hiddenapi::kReflection，除此之外还有其他几种模式，如下</p>
<h4 id="2-4-1-AccessMethod"><a href="#2-4-1-AccessMethod" class="headerlink" title="2.4.1 AccessMethod"></a>2.4.1 AccessMethod</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> AccessMethod &#123;</span><br><span class="line">  kNone,        <span class="comment">// 测试模式，不会出现在实际场景访问权限</span></span><br><span class="line">  kReflection,  <span class="comment">// Java反射调用</span></span><br><span class="line">  kJNI,         <span class="comment">// JNI调用过程</span></span><br><span class="line">  kLinking,     <span class="comment">// 动态链接过程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-限制场景"><a href="#2-4-2-限制场景" class="headerlink" title="2.4.2 限制场景"></a>2.4.2 限制场景</h4><p>ShouldBlockAccessToMember是限制内部API访问的核心路径</p>
<ul>
<li>kReflection反射过程：<ul>
<li>Class_newInstance：对象实例化</li>
<li>Class_getDeclaredConstructorInternal：构造方法</li>
<li>Class_getDeclaredMethodInternal：获取方法</li>
<li>Class_getDeclaredField：获取字段</li>
<li>Class_getPublicFieldRecursive：获取字段</li>
</ul>
</li>
<li>kJNI的JNI调用过程：<ul>
<li>FindMethodID：查找方法</li>
<li>FindFieldID：查找字段</li>
</ul>
</li>
<li>kLinking动态链接：<ul>
<li>UnstartedClassNewInstance</li>
<li>UnstartedClassGetDeclaredConstructor</li>
<li>UnstartedClassGetDeclaredMethod</li>
<li>UnstartedClassGetDeclaredField</li>
</ul>
</li>
</ul>
<h3 id="2-5-GetMemberAction"><a href="#2-5-GetMemberAction" class="headerlink" title="2.5 GetMemberAction"></a>2.5 GetMemberAction</h3><p>[-&gt; hidden_api.h]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Action <span class="title">GetMemberAction</span><span class="params">(T* member,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Thread* self,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>(Thread*)&gt; fn_caller_is_trusted,</span></span></span><br><span class="line"><span class="function"><span class="params">                              AccessMethod access_method)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取hidenn API的可访问标识</span></span><br><span class="line">  HiddenApiAccessFlags::ApiList api_list = member-&gt;GetHiddenApiAccessFlags();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取相应的访问行为【小节2.6】</span></span><br><span class="line">  Action action = GetActionFromAccessFlags(member-&gt;GetHiddenApiAccessFlags());</span><br><span class="line">  <span class="keyword">if</span> (action == kAllow) &#123;  <span class="comment">//允许则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//检测是否平台调用【小节2.7】</span></span><br><span class="line">  <span class="keyword">if</span> (fn_caller_is_trusted(self)) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllow;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于hidden接口，且非平台调用【小节2.8】</span></span><br><span class="line">  <span class="keyword">return</span> detail::GetMemberActionImpl(member, api_list, action, access_method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能说明：</p>
<ul>
<li>当Action=kAllow，则直接返回；否则执行如下：</li>
<li>通过fn_caller_is_trusted看当前是否是系统调用的，如果是系统调用则返回，否则执行如下：</li>
<li>通过GetMemberActionImpl()做进一步判断</li>
</ul>
<p>此处的fn_caller_is_trusted是指IsCallerTrusted</p>
<h3 id="2-6-GetActionFromAccessFlags"><a href="#2-6-GetActionFromAccessFlags" class="headerlink" title="2.6 GetActionFromAccessFlags"></a>2.6 GetActionFromAccessFlags</h3><p>[-&gt; hidden_api.h]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Action <span class="title">GetActionFromAccessFlags</span><span class="params">(HiddenApiAccessFlags::ApiList api_list)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (api_list == HiddenApiAccessFlags::kWhitelist) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllow;   <span class="comment">//位于白名单，则允许访问</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EnforcementPolicy policy = Runtime::Current()-&gt;GetHiddenApiEnforcementPolicy();</span><br><span class="line">  <span class="keyword">if</span> (policy == EnforcementPolicy::kNoChecks) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllow;  <span class="comment">//非强制执行策略，则允许访问</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (policy == EnforcementPolicy::kJustWarn) &#123;</span><br><span class="line">    <span class="keyword">return</span> kAllowButWarn;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行到这，policy&gt;=kDarkGreyAndBlackList</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(policy) &gt; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(api_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> api_list == HiddenApiAccessFlags::kDarkGreylist</span><br><span class="line">        ? kAllowButWarnAndToast : kAllowButWarn;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> kDeny;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上逻辑用图来展示EnforcementPolicy和HiddenApiAccessFlags在不同取值的情况下，所对应的Action值。 纵轴代表强制策略级别，横轴代表隐藏API的标识，表中数据代表Action，如下所示：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>kWhitelist</th>
<th>kLightGreylist</th>
<th>kDarkGreylist</th>
<th>kBlacklist</th>
</tr>
</thead>
<tbody><tr>
<td>kNoChecks</td>
<td>kAllow</td>
<td>kAllow</td>
<td>kAllow</td>
<td>kAllow</td>
</tr>
<tr>
<td>kJustWarn</td>
<td>kAllow</td>
<td>kAllowButWarn</td>
<td>kAllowButWarn</td>
<td>kAllowButWarn</td>
</tr>
<tr>
<td>kDarkGreyAndBlackList</td>
<td>kAllow</td>
<td>kAllowButWarn</td>
<td>kDeny</td>
<td>kDeny</td>
</tr>
<tr>
<td>kBlacklistOnly</td>
<td>kAllow</td>
<td>kAllowButWarn</td>
<td>kAllowButWarnAndToast</td>
<td>kDeny</td>
</tr>
</tbody></table>
<p>图解：</p>
<ul>
<li>当HiddenApiAccessFlags等于kWhitelist，则Action=kAllow，否则如下</li>
<li>当EnforcementPolicy等于kNoChecks，则Action=kAllow，否则如下</li>
<li>当EnforcementPolicy等于kJustWarn，则Action=kAllowButWarn，否则如下</li>
<li>当HiddenApiAccessFlags等于kLightGreylist，则Action=kAllowButWarn，否则如下</li>
<li>当HiddenApiAccessFlags等于kDarkGreylist，且等于EnforcementPolicy=kBlacklistOnly，则kAllowButWarnAndToast，否则如下</li>
<li>否则Action=kDeny</li>
</ul>
<h4 id="2-6-1-EnforcementPolicy"><a href="#2-6-1-EnforcementPolicy" class="headerlink" title="2.6.1 EnforcementPolicy"></a>2.6.1 EnforcementPolicy</h4><p>EnforcementPolicy的级别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">EnforcementPolicy</span> &#123;</span></span><br><span class="line">  kNoChecks             = <span class="number">0</span>,</span><br><span class="line">  kJustWarn             = <span class="number">1</span>,  <span class="comment">// 保持检查，一切都允许(仅仅记录日志)</span></span><br><span class="line">  kDarkGreyAndBlackList = <span class="number">2</span>,  <span class="comment">// 禁止深灰色和黑名单</span></span><br><span class="line">  kBlacklistOnly        = <span class="number">3</span>,  <span class="comment">// 只禁止黑名单</span></span><br><span class="line">  kMax = kBlacklistOnly,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可通过SetHiddenApiEnforcementPolicy()来修改Runtime中的成员变量hidden_api_policy_。</p>
<h4 id="2-6-2-HiddenApiAccessFlags"><a href="#2-6-2-HiddenApiAccessFlags" class="headerlink" title="2.6.2 HiddenApiAccessFlags"></a>2.6.2 HiddenApiAccessFlags</h4><p>HiddenApiAccessFlags的级别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HiddenApiAccessFlags</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> ApiList &#123;</span><br><span class="line">    kWhitelist = <span class="number">0</span>,</span><br><span class="line">    kLightGreylist,</span><br><span class="line">    kDarkGreylist,</span><br><span class="line">    kBlacklist,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3-Action"><a href="#2-6-3-Action" class="headerlink" title="2.6.3 Action"></a>2.6.3 Action</h4><p>Action级别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Action &#123;</span><br><span class="line">  kAllow,         <span class="comment">//通过</span></span><br><span class="line">  kAllowButWarn,  <span class="comment">//通过，但日志警告</span></span><br><span class="line">  kAllowButWarnAndToast,  <span class="comment">//通过，且日志警告和弹窗</span></span><br><span class="line">  kDeny   <span class="comment">//拒绝访问</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-IsCallerTrusted"><a href="#2-7-IsCallerTrusted" class="headerlink" title="2.7 IsCallerTrusted"></a>2.7 IsCallerTrusted</h3><p>[-&gt; java_lang_Class.cc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsCallerTrusted</span><span class="params">(Thread* self)</span> <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function">FirstExternalCallerVisitor <span class="title">visitor</span><span class="params">(self)</span></span>;</span><br><span class="line">    visitor.WalkStack();</span><br><span class="line">    <span class="comment">//【见小节2.7.1】</span></span><br><span class="line">    <span class="keyword">return</span> visitor.caller != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">           hiddenapi::IsCallerTrusted(visitor.caller-&gt;GetDeclaringClass());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-7-1-IsCallerTrusted"><a href="#2-7-1-IsCallerTrusted" class="headerlink" title="2.7.1 IsCallerTrusted"></a>2.7.1 IsCallerTrusted</h4><p>[-&gt; hidden_api.h]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ALWAYS_INLINE</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsCallerTrusted</span><span class="params">(ObjPtr&lt;mirror::Class&gt; caller,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ObjPtr&lt;mirror::ClassLoader&gt; caller_class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ObjPtr&lt;mirror::DexCache&gt; caller_dex_cache)</span></span></span><br><span class="line"><span class="function">    <span class="title">REQUIRES_SHARED</span><span class="params">(Locks::mutator_lock_)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (caller_class_loader.IsNull()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Boot classloader，则返回true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!caller_dex_cache.IsNull()) &#123;</span><br><span class="line">    <span class="keyword">const</span> DexFile* caller_dex_file = caller_dex_cache-&gt;GetDexFile();</span><br><span class="line">    <span class="keyword">if</span> (caller_dex_file != <span class="literal">nullptr</span> &amp;&amp; caller_dex_file-&gt;IsPlatformDexFile()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// caller是平台dex文件，则返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!caller.IsNull() &amp;&amp;</span><br><span class="line">      caller-&gt;ShouldSkipHiddenApiChecks() &amp;&amp;</span><br><span class="line">      Runtime::Current()-&gt;IsJavaDebuggable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//处于debuggable调试模式且caller已被标记可信任，则返回true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>caller被认为是可信任的场景如下：</p>
<ul>
<li>当类加载器是Boot classloader，则返回true</li>
<li>当caller是平台dex文件，则返回true</li>
<li>处于debuggable调试模式且caller已被标记可信任，则返回true</li>
</ul>
<h3 id="2-8-GetMemberActionImpl"><a href="#2-8-GetMemberActionImpl" class="headerlink" title="2.8 GetMemberActionImpl"></a>2.8 GetMemberActionImpl</h3><p>[-&gt; hidden_api.cc]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="function">Action <span class="title">GetMemberActionImpl</span><span class="params">(T* member,</span></span></span><br><span class="line"><span class="function"><span class="params">                           HiddenApiAccessFlags::ApiList api_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Action action,</span></span></span><br><span class="line"><span class="function"><span class="params">                           AccessMethod access_method)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取签名</span></span><br><span class="line">  <span class="function">MemberSignature <span class="title">member_signature</span><span class="params">(member)</span></span>;</span><br><span class="line">  Runtime* runtime = Runtime::Current();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> bool shouldWarn = kLogAllAccesses || runtime-&gt;IsJavaDebuggable();</span><br><span class="line">  <span class="keyword">if</span> (shouldWarn || action == kDeny) &#123;</span><br><span class="line">    <span class="comment">//判断是否为可豁免接口【小节2.8.1】</span></span><br><span class="line">    <span class="keyword">if</span> (member_signature.IsExempted(runtime-&gt;GetHiddenApiExemptions())) &#123;</span><br><span class="line">      action = kAllow;</span><br><span class="line">      MaybeWhitelistMember(runtime, member);</span><br><span class="line">      <span class="keyword">return</span> kAllow;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (access_method != kNone) &#123;</span><br><span class="line">      <span class="comment">//打印包含有关此类成员访问信息的日志消息【小节2.8.2】</span></span><br><span class="line">      member_signature.WarnAboutAccess(access_method, api_list);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (action == kDeny) &#123;</span><br><span class="line">    <span class="keyword">return</span> action; <span class="comment">//拒绝调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (access_method != kNone) &#123;</span><br><span class="line">    <span class="comment">// 根据运行时标志的不同，我们可以将成员移动到白名单中，并在下次访问成员时跳过警告。</span></span><br><span class="line">    MaybeWhitelistMember(runtime, member);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果此操作需要UI警告，设置适当的标志</span></span><br><span class="line">    <span class="keyword">if</span> (shouldWarn &amp;&amp;</span><br><span class="line">        (action == kAllowButWarnAndToast || runtime-&gt;ShouldAlwaysSetHiddenApiWarningFlag())) &#123;</span><br><span class="line">      runtime-&gt;SetPendingHiddenApiWarning(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-8-1-GetHiddenApiExemptions"><a href="#2-8-1-GetHiddenApiExemptions" class="headerlink" title="2.8.1 GetHiddenApiExemptions"></a>2.8.1 GetHiddenApiExemptions</h4><p>[-&gt; runtime.h]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// SetHiddenApiEnforcementPolicy()可修改该值</span></span><br><span class="line">    hiddenapi::EnforcementPolicy hidden_api_policy_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SetHiddenApiExemptions()可修改该值</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; hidden_api_exemptions_;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetHiddenApiExemptions()是获取Runtime里面的成员变量hidden_api_exemptions_</p>
<h4 id="2-8-2-WarnAboutAccess"><a href="#2-8-2-WarnAboutAccess" class="headerlink" title="2.8.2 WarnAboutAccess"></a>2.8.2 WarnAboutAccess</h4><p>[-&gt; hidden_api.cc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MemberSignature::WarnAboutAccess</span><span class="params">(AccessMethod access_method,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      HiddenApiAccessFlags::ApiList <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">  LOG(WARNING) &lt;&lt; <span class="string">"Accessing hidden "</span> &lt;&lt; (type_ == kField ? <span class="string">"field "</span> : <span class="string">"method "</span>)</span><br><span class="line">               &lt;&lt; Dumpable&lt;MemberSignature&gt;(*<span class="keyword">this</span>) &lt;&lt; <span class="string">" ("</span> &lt;&lt; <span class="built_in">list</span> &lt;&lt; ", " &lt;&lt; access_method &lt;&lt; ")";</span><br></pre></td></tr></table></figure>

<p>打印包含有关此类成员访问信息的日志消息</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><h4 id="3-1-限制原理总结"><a href="#3-1-限制原理总结" class="headerlink" title="3.1 限制原理总结"></a>3.1 限制原理总结</h4><p>（1）从前面的内部API限制过程，可知主要控制逻辑在方法ShouldBlockAccessToMember，调用该方法的核心路径如下：</p>
<ul>
<li>kReflection反射过程：<ul>
<li>Class_newInstance：对象实例化</li>
<li>Class_getDeclaredConstructorInternal：构造方法</li>
<li>Class_getDeclaredMethodInternal：获取方法</li>
<li>Class_getDeclaredField：获取字段</li>
<li>Class_getPublicFieldRecursive：获取字段</li>
</ul>
</li>
<li>kJNI的JNI调用过程：<ul>
<li>FindMethodID：查找方法</li>
<li>FindFieldID：查找字段</li>
</ul>
</li>
<li>kLinking动态链接：<ul>
<li>UnstartedClassNewInstance</li>
<li>UnstartedClassGetDeclaredConstructor</li>
<li>UnstartedClassGetDeclaredMethod</li>
<li>UnstartedClassGetDeclaredField</li>
</ul>
</li>
</ul>
<p>（2）ShouldBlockAccessToMember过程是否运行主要有如下情况：</p>
<ul>
<li>当EnforcementPolicy强制不限制的情况</li>
<li>当类加载器是Boot classloader的情况</li>
<li>当caller是平台dex文件的情况</li>
<li>当处于debuggable调试模式且caller已被标记可信任的情况</li>
<li>当GetHiddenApiExemptions为豁免情况</li>
</ul>
<p>（3）掌握了ShouldBlockAccessToMember原理，也就可以有的放矢了，突破限制方案，比如：</p>
<ul>
<li>修改ART的EnforcementPolicy，也就是Runtime中的成员变量hidden_api_policy_，可以基于地址偏移找到相应的成员，这就不就细说</li>
<li>修改隐藏API豁免变量，也就是Runtime中的成员变量hidden_api_exemptions_</li>
<li>修改classLoader为BootClassLoader</li>
</ul>
<h4 id="3-2-黑白名单"><a href="#3-2-黑白名单" class="headerlink" title="3.2 黑白名单"></a>3.2 黑白名单</h4><p>关于在Android P的几个预览版本一直在不断调整，目前主要是黑名单、浅灰名单、vendor名单这3个名单，对应文件名：hiddenapi-force-blacklist.txt，hiddenapi-light-greylist.txt，hiddenapi-vendor-list.txt。这些文件在编译阶段生成为hiddenapi，记录在access_flags_字段值。整个过程是在hiddenapi.cc过程的CategorizeAllClasses()中完成的。</p>
<p><img src="http://gityuan.com/images/hidden-api/android_hideapi.png" alt="hidden-api-exp"></p>
<p>目前主要使用的是黑名单和浅灰名单，深灰名单暂没有使用：</p>
<ul>
<li>黑名单内容：setHiddenApiExemptions</li>
<li>浅灰名单内容：Activity, Service，ContentProvider，ActivityManager, ActivityThread，Application，ContextImpl，Intent等</li>
</ul>
<h4 id="3-3-非SDK接口说明"><a href="#3-3-非SDK接口说明" class="headerlink" title="3.3 非SDK接口说明"></a>3.3 非SDK接口说明</h4><ol>
<li>非SDK接口限制适用于所有应用，但是会豁免使用平台密钥签署的应用，并且针对系统app的白名单</li>
<li>如果你的应用有必须使用非SDK接口的充分理由，可以向Google提交<a href="https://issuetracker.google.com/issues/new?component=328403&template=1027267" target="_blank" rel="noopener">功能请求</a>，并提供用例详情;</li>
<li>如果你的应用使用很多第三方库，而又难以排除是否正在使用非SDK接口，可以尝试使用AOSP提供的静态分析工具<a href="https://android.googlesource.com/platform/prebuilts/runtime/+/master/appcompat" target="_blank" rel="noopener">veridex</a>;</li>
<li>应用运行时检测到非SDK接口的使用，会打印一条<code>Accessing hidden field|method ...</code> 形式的logcat警告。当然对于设置android:debuggable=true的可调试应用会显示toast消息，并打印logcat日志。</li>
<li>黑名单/灰名单编码在平台dex文件的字段和函数访问标志位中，无法从系统镜像中找到单独包含这些名单的文件。</li>
<li>黑名单/灰名单在采用相同Android版本是一致的。手机厂商可以向黑名单添加自己的API，但无法从AOSP黑名单或灰名单中移除，Google兼容性定义文件(CDD)来保障这一工作，并在测试过程通过CTS来确保Android运行时强制执行名单。</li>
<li>目前，Google对Android暂时没有限制访问dex2oat二进制文件的计划，但是dex文件格式无法保证会稳定，可能随时会修改或删除dex2oat以及dex衍生文件。</li>
</ol>
<p>Android 7.0针对Native lib引入了namespace来限制平台lib对外的可见性，普通APP在Android N上不能直接调用系统私有库，Android系统允许调用的公用库定义在<a href="https://android.googlesource.com/platform/system/core/+/refs/heads/master/rootdir/etc/public.libraries.android.txt" target="_blank" rel="noopener">public.libraries.android.txt</a>。 这个feature只针对target SDK为24及以上的APP。</p>
<p>Android 7.0限制对C/C++代码的NDK，Android 9.0限制对Java的SDK。这一以来APP想利用内部API搞黑科技的难度以及不稳定性都会有所增加。</p>
<p>最后说一点，目前网络有一些开发者发表了关于非SDK接口限制的绕过技术，但基本没有APP是通过这些漏洞方式来突破隐藏API的访问，说明大家有所顾忌，这对生态来说是好事。另外关于绕过技术对于Google和手机厂商都已注意到，要简单封杀容易但可能会带来调试与复杂度的提升，所以Google正在积极寻找平衡接口限制与运行时易于调试之间的平衡，相信很快Google会有更完善的解决方案。</p>
]]></content>
  </entry>
</search>
